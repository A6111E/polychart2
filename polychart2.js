/*
 * Polychart.js
 * Copyright (c) Polychart Inc
 * All Rights Reserved
 */
window.polyjs = (function(poly) {
  if (!poly) {
  poly = {};
// Generated by CoffeeScript 1.4.0

/*
Group an array of data items by the value of certain columns.

Input:
- `data`: an array of data items
- `group`: an array of column keys, to group by
Output:
- an associate array of key: array of data, with the appropriate grouping
  the `key` is a string of format "columnKey:value;colunmKey2:value2;..."
*/


(function() {

  poly.groupBy = function(data, group) {
    return _.groupBy(data, poly.stringify(group));
  };

  poly.stringify = function(group) {
    return function(item) {
      var concat;
      concat = function(memo, g) {
        return "" + memo + g + ":" + item[g] + ";";
      };
      return _.reduce(group, concat, "");
    };
  };

  poly.cross = function(keyVals, ignore) {
    var arrs, i, item, items, next, todo, val, _i, _j, _len, _len1, _ref;
    if (ignore == null) {
      ignore = [];
    }
    todo = _.difference(_.keys(keyVals), ignore);
    if (todo.length === 0) {
      return [{}];
    }
    arrs = [];
    next = todo[0];
    items = poly.cross(keyVals, ignore.concat(next));
    _ref = keyVals[next];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      val = _ref[_i];
      for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
        item = items[_j];
        i = _.clone(item);
        i[next] = val;
        arrs.push(i);
      }
    }
    return arrs;
  };

  /*
  Take a processedData from the data processing step and group it for faceting
  purposes.
  
  Input is in the format: 
  processData = {
    layer_id : { statData: [...], metaData: {...} }
    ...
  }
  
  Output should be in one of the two format:
    groupedData = {
      grouped: true
      key: group1
      values: {
        value1: groupedData2 # note recursive def'n
        value2: groupedData3
        ...
      }
    }
    OR
    groupedData = {
      layer_id : { statData: [...], metaData: {...} }
      ...
    }
  */


  poly.groupProcessedData = function(processedData, groups) {
    var currGrp, data, index, newProcessedData, result, uniqueValues, value, _i, _len;
    if (groups.length === 0) {
      return processedData;
    }
    currGrp = groups.splice(0, 1)[0];
    uniqueValues = [];
    for (index in processedData) {
      data = processedData[index];
      if (currGrp in data.metaData) {
        uniqueValues = _.union(uniqueValues, _.uniq(_.pluck(data.statData, currGrp)));
      }
    }
    result = {
      grouped: true,
      key: currGrp,
      values: {}
    };
    for (_i = 0, _len = uniqueValues.length; _i < _len; _i++) {
      value = uniqueValues[_i];
      newProcessedData = {};
      for (index in processedData) {
        data = processedData[index];
        newProcessedData[index] = {
          metaData: data.metaData
        };
        newProcessedData[index].statData = currGrp in data.metaData ? poly.filter(data.statData, currGrp, value) : _.clone(data.statData);
      }
      result.values[value] = poly.groupProcessedData(newProcessedData, _.clone(groups));
    }
    return result;
  };

  poly.filter = function(statData, key, val) {
    var item, newData, _i, _len;
    newData = [];
    for (_i = 0, _len = statData.length; _i < _len; _i++) {
      item = statData[_i];
      if (item[key] === val) {
        newData.push(item);
      }
    }
    return newData;
  };

  /*
  Produces a linear function that passes through two points.
  Input:
  - `x1`: x coordinate of the first point
  - `y1`: y coordinate of the first point
  - `x2`: x coordinate of the second point
  - `y2`: y coordinate of the second point
  Output:
  - A function that, given the x-coord, returns the y-coord
  */


  poly.linear = function(x1, y1, x2, y2) {
    return function(x) {
      return (y2 - y1) / (x2 - x1) * (x - x1) + y1;
    };
  };

  /*
  given a sorted list and a midpoint calculate the median
  */


  poly.median = function(values, sorted) {
    var mid;
    if (sorted == null) {
      sorted = false;
    }
    if (!sorted) {
      values = _.sortBy(values, function(x) {
        return x;
      });
    }
    mid = values.length / 2;
    if (mid % 1 !== 0) {
      return values[Math.floor(mid)];
    }
    return (values[mid - 1] + values[mid]) / 2;
  };

  /*
  Produces a function that counts how many times it has been called
  */


  poly.counter = function() {
    var i;
    i = 0;
    return function() {
      return i++;
    };
  };

  /*
  Sample an associate array (object)
  */


  poly.sample = function(assoc, num) {
    return _.pick(assoc, _.shuffle(_.keys(assoc)).splice(0, num));
  };

  /*
  Given an OLD array and NEW array, split the points in (OLD union NEW) into
  three sets:
    - deleted
    - kept
    - added
  */


  poly.compare = function(oldarr, newarr) {
    var added, deleted, kept, newElem, newIndex, oldElem, oldIndex, sortedNewarr, sortedOldarr;
    sortedOldarr = _.sortBy(oldarr, function(x) {
      return x;
    });
    sortedNewarr = _.sortBy(newarr, function(x) {
      return x;
    });
    deleted = [];
    kept = [];
    added = [];
    oldIndex = newIndex = 0;
    while (oldIndex < sortedOldarr.length || newIndex < sortedNewarr.length) {
      oldElem = sortedOldarr[oldIndex];
      newElem = sortedNewarr[newIndex];
      if (oldIndex >= sortedOldarr.length) {
        added.push(newElem);
        newIndex += 1;
      } else if (newIndex >= sortedNewarr.length) {
        deleted.push(oldElem);
        oldIndex += 1;
      } else if (oldElem < newElem) {
        deleted.push(oldElem);
        oldIndex += 1;
      } else if (oldElem > newElem) {
        added.push(newElem);
        newIndex += 1;
      } else if (oldElem === newElem) {
        kept.push(oldElem);
        oldIndex += 1;
        newIndex += 1;
      } else {
        throw DataError("Unknown data encounted");
      }
    }
    return {
      deleted: deleted,
      kept: kept,
      added: added
    };
  };

  /*
  Given an aesthetic mapping in the "geom" object, flatten it and extract only
  the values from it. This is so that even if a compound object is encoded in an
  aestehtic, we have the correct set of values to calculate the min/max.
  */


  poly.flatten = function(values) {
    var flat, k, v, _i, _len;
    flat = [];
    if (values != null) {
      if (_.isObject(values)) {
        if (values.t === 'scalefn') {
          if (values.f !== 'novalue') {
            flat.push(values.v);
          }
        } else {
          for (k in values) {
            v = values[k];
            flat = flat.concat(poly.flatten(v));
          }
        }
      } else if (_.isArray(values)) {
        for (_i = 0, _len = values.length; _i < _len; _i++) {
          v = values[_i];
          flat = flat.concat(poly.flatten(v));
        }
      } else {
        flat.push(values);
      }
    }
    return flat;
  };

  /*
  GET LABEL
  TODO: move somewhere else and allow overwrite by user
  */


  poly.getLabel = function(layers, aes) {
    return _.chain(layers).map(function(l) {
      return l.mapping[aes];
    }).without(null, void 0).uniq().value().join(' | ');
  };

  /*
  Estimate the number of pixels rendering this string would take...?
  */


  poly.strSize = function(str) {
    return (str + "").length * 7;
  };

  /*
  Sort Arrays: given a sorting function and some number of arrays, sort all the
  arrays by the function applied to the first array. This is used for sorting
  points for a line chart, i.e. poly.sortArrays(sortFn, [xs, ys])
  
  This way, all the points are sorted by (sortFn(x) for x in xs)
  */


  poly.sortArrays = function(fn, arrays) {
    var zipped;
    zipped = _.zip.apply(_, arrays);
    zipped.sort(function(a, b) {
      return fn(a[0], b[0]);
    });
    return _.zip.apply(_, zipped);
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
CONSTANTS
---------
These are constants that are referred to throughout the coebase
*/


(function() {

  poly["const"] = {
    aes: ['x', 'y', 'color', 'size', 'opacity', 'shape', 'id', 'text'],
    noDomain: ['id', 'text', 'tooltip'],
    noLegend: ['x', 'y', 'id', 'text', 'tooltip'],
    trans: {
      'bin': ['key', 'binwidth'],
      'lag': ['key', 'lag']
    },
    stat: {
      'count': ['key'],
      'sum': ['key'],
      'mean': ['key'],
      'box': ['key'],
      'median': ['key']
    },
    timerange: ['second', 'minute', 'hour', 'day', 'week', 'month', '2month', 'quarter', '6month', 'year', '2year', '5year', 'decade'],
    metas: {
      sort: null,
      stat: null,
      limit: null,
      asc: true
    },
    scaleFns: {
      novalue: function() {
        return {
          v: null,
          f: 'novalue',
          t: 'scalefn'
        };
      },
      max: function(v) {
        return {
          v: v,
          f: 'max',
          t: 'scalefn'
        };
      },
      min: function(v) {
        return {
          v: v,
          f: 'min',
          t: 'scalefn'
        };
      },
      upper: function(v, n, m) {
        return {
          v: v,
          n: n,
          m: m,
          f: 'upper',
          t: 'scalefn'
        };
      },
      lower: function(v, n, m) {
        return {
          v: v,
          n: n,
          m: m,
          f: 'lower',
          t: 'scalefn'
        };
      },
      middle: function(v) {
        return {
          v: v,
          f: 'middle',
          t: 'scalefn'
        };
      },
      jitter: function(v) {
        return {
          v: v,
          f: 'jitter',
          t: 'scalefn'
        };
      },
      identity: function(v) {
        return {
          v: v,
          f: 'identity',
          t: 'scalefn'
        };
      }
    },
    epsilon: Math.pow(10, -7),
    defaults: {
      'x': {
        v: null,
        f: 'novalue',
        t: 'scalefn'
      },
      'y': {
        v: null,
        f: 'novalue',
        t: 'scalefn'
      },
      'color': 'steelblue',
      'size': 2,
      'opacity': 0.7
    }
  };

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var DataError, DefinitionError, DependencyError, ModeError, NotImplemented, UnknownInput,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  DefinitionError = (function(_super) {

    __extends(DefinitionError, _super);

    function DefinitionError(message) {
      this.message = message;
      this.name = "DefinitionError";
    }

    return DefinitionError;

  })(Error);

  DependencyError = (function(_super) {

    __extends(DependencyError, _super);

    function DependencyError(message) {
      this.message = message;
      this.name = "DependencyError";
    }

    return DependencyError;

  })(Error);

  ModeError = (function(_super) {

    __extends(ModeError, _super);

    function ModeError(message) {
      this.message = message;
      this.name = "ModeError";
    }

    return ModeError;

  })(Error);

  DataError = (function(_super) {

    __extends(DataError, _super);

    function DataError(message) {
      this.message = message;
      this.name = "DataError";
    }

    return DataError;

  })(Error);

  UnknownInput = (function(_super) {

    __extends(UnknownInput, _super);

    function UnknownInput(message) {
      this.message = message;
      this.name = "UnknownInput";
    }

    return UnknownInput;

  })(Error);

  NotImplemented = (function(_super) {

    __extends(NotImplemented, _super);

    function NotImplemented(message) {
      this.message = message;
      this.name = "ModeError";
    }

    return NotImplemented;

  })(Error);

  poly.error = function(msg) {
    return new Error(msg);
  };

  poly.error.data = function(msg) {
    return new DataError(msg);
  };

  poly.error.depn = function(msg) {
    return new DependencyError(msg);
  };

  poly.error.defn = function(msg) {
    return new DefinitionError(msg);
  };

  poly.error.mode = function(msg) {
    return new ModeError(msg);
  };

  poly.error.impl = function(msg) {
    return new NotImplemented(msg);
  };

  poly.error.input = function(msg) {
    return new UnknownInput(msg);
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Abstract Classes
---------
Abstract classes, almost used like interfaces throughout the codebase
*/


(function() {
  var Geometry, Guide, GuideSet, Renderable,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Renderable = (function() {

    function Renderable() {}

    Renderable.prototype.render = function() {
      return poly.error.impl();
    };

    Renderable.prototype.dispose = function() {
      return poly.error.impl();
    };

    return Renderable;

  })();

  Guide = (function(_super) {

    __extends(Guide, _super);

    function Guide() {
      return Guide.__super__.constructor.apply(this, arguments);
    }

    Guide.prototype.getDimension = function() {
      throw poly.error.impl();
    };

    return Guide;

  })(Renderable);

  GuideSet = (function(_super) {

    __extends(GuideSet, _super);

    function GuideSet() {
      return GuideSet.__super__.constructor.apply(this, arguments);
    }

    GuideSet.prototype.getDimension = function() {
      throw poly.error.impl();
    };

    GuideSet.prototype.make = function() {
      throw poly.error.impl();
    };

    return GuideSet;

  })(Renderable);

  /*
  This should probably be in its own class folder, and should technically
  be named "Renderable", but whatever. It manages what is currently on the
  screen, and what needs to be rendered.
    @geoms : a key-value pair of an identifier to a group of objects to be
             rendered. It should be of the following form:
              @geoms = {
                'id' : {
                  marks: {
                    # an assoc array of renderable "marks", acceptable by 
                    # poly.render() function
                  },
                  evtData: {
                    # data bound to a click/mouseover/mouseout event
                    # on the marks plotted
                  },
                  tooltip: # tooltip text to show on mouseover
                }
              }
    @pts   : a key-value pair of identfier to a group of objects rendered.
             the group of objects is also a key-value pair, corresponding
             to the key-value pair provided by `marks` as above.
  */


  Geometry = (function(_super) {

    __extends(Geometry, _super);

    function Geometry() {
      this.dispose = __bind(this.dispose, this);
      this.geoms = {};
      this.pts = {};
    }

    Geometry.prototype.set = function(geoms) {
      return this.geoms = geoms;
    };

    Geometry.prototype.render = function(renderer) {
      var added, deleted, id, kept, newpts, _i, _j, _k, _len, _len1, _len2, _ref;
      newpts = {};
      _ref = poly.compare(_.keys(this.pts), _.keys(this.geoms)), deleted = _ref.deleted, kept = _ref.kept, added = _ref.added;
      for (_i = 0, _len = deleted.length; _i < _len; _i++) {
        id = deleted[_i];
        this._delete(renderer, this.pts[id]);
      }
      for (_j = 0, _len1 = added.length; _j < _len1; _j++) {
        id = added[_j];
        newpts[id] = this._add(renderer, this.geoms[id]);
      }
      for (_k = 0, _len2 = kept.length; _k < _len2; _k++) {
        id = kept[_k];
        newpts[id] = this._modify(renderer, this.pts[id], this.geoms[id]);
      }
      return this.pts = newpts;
    };

    Geometry.prototype._delete = function(renderer, points) {
      var id2, pt, _results;
      _results = [];
      for (id2 in points) {
        pt = points[id2];
        _results.push(renderer.remove(pt));
      }
      return _results;
    };

    Geometry.prototype._modify = function(renderer, points, geom) {
      var id2, mark, objs, _ref;
      objs = {};
      _ref = geom.marks;
      for (id2 in _ref) {
        mark = _ref[id2];
        objs[id2] = renderer.animate(points[id2], mark, geom.evtData, geom.tooltip);
      }
      return objs;
    };

    Geometry.prototype._add = function(renderer, geom) {
      var id2, mark, objs, _ref;
      objs = {};
      _ref = geom.marks;
      for (id2 in _ref) {
        mark = _ref[id2];
        objs[id2] = renderer.add(mark, geom.evtData, geom.tooltip);
      }
      return objs;
    };

    Geometry.prototype.dispose = function(renderer) {
      var id, pt, _ref;
      _ref = this.pts;
      for (id in _ref) {
        pt = _ref[id];
        this._delete(renderer, pt);
      }
      return this.pts = {};
    };

    return Geometry;

  })(Renderable);

  poly.Renderable = Renderable;

  poly.Guide = Guide;

  poly.GuideSet = GuideSet;

  poly.Geometry = Geometry;

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Get the offset of the element
*/


(function() {

  poly.offset = function(elem) {
    var box, doc, docElem, win;
    box = {
      top: 0,
      left: 0
    };
    doc = elem && elem.ownerDocument;
    if (!doc) {
      return;
    }
    docElem = doc.documentElement;
    if (typeof elem.getBoundingClientRect !== "undefined") {
      box = elem.getBoundingClientRect();
    }
    win = doc !== null && doc === doc.window ? doc : doc.nodeType === 9 && doc.defaultView;
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  };

  /*
  Get the raphael (x,y) position of a mouse event
  */


  poly.getXY = function(offset, e) {
    var scrollX, scrollY, x, y, _ref, _ref1;
    x = e.clientX;
    y = e.clientY;
    scrollY = (_ref = document.documentElement.scrollTop) != null ? _ref : document.body.scrollTop;
    scrollX = (_ref1 = document.documentElement.scrollLeft) != null ? _ref1 : document.body.scrollLeft;
    return {
      x: x + scrollX - offset.left,
      y: y + scrollY - offset.top
    };
  };

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var POSTFIXES, formatNumber, postfix;

  poly.format = function(type, step) {
    switch (type) {
      case 'cat':
        return poly.format.identity;
      case 'num':
        return poly.format.number(step);
      case 'date':
        return poly.format.date(step);
      case 'none':
        return poly.format.identity;
    }
  };

  poly.format.identity = function(x) {
    return x;
  };

  POSTFIXES = {
    0: '',
    3: 'k',
    6: 'm',
    9: 'b',
    12: 't'
  };

  postfix = function(num, pow) {
    if (!_.isUndefined(POSTFIXES[pow])) {
      return num + POSTFIXES[pow];
    } else {
      return num + 'e' + (pow > 0 ? '+' : '-') + Math.abs(pow);
    }
  };

  formatNumber = function(n) {
    var abs, i, s, v;
    if (!isFinite(n)) {
      return n;
    }
    s = "" + n;
    abs = Math.abs(n);
    if (abs >= 1000) {
      v = ("" + abs).split(/\./);
      i = v[0].length % 3 || 3;
      v[0] = s.slice(0, i + (n < 0)) + v[0].slice(i).replace(/(\d{3})/g, ',$1');
      s = v.join('.');
    }
    return s;
  };

  poly.format.number = function(exp_original) {
    return function(num) {
      var exp, exp_fixed, exp_precision, rounded;
      exp_fixed = 0;
      exp_precision = 0;
      exp = exp_original != null ? exp_original : Math.floor(Math.log(Math.abs(num === 0 ? 1 : num)) / Math.LN10);
      if ((exp_original != null) && (exp === 2 || exp === 5 || exp === 8 || exp === 11)) {
        exp_fixed = exp + 1;
        exp_precision = 1;
      } else if (exp === -1) {
        exp_fixed = 0;
        exp_precision = exp_original != null ? 1 : 2;
      } else if (exp === -2) {
        exp_fixed = 0;
        exp_precision = exp_original != null ? 2 : 3;
      } else if (exp === 1 || exp === 2) {
        exp_fixed = 0;
      } else if (exp > 3 && exp < 6) {
        exp_fixed = 3;
      } else if (exp > 6 && exp < 9) {
        exp_fixed = 6;
      } else if (exp > 9 && exp < 12) {
        exp_fixed = 9;
      } else if (exp > 12 && exp < 15) {
        exp_fixed = 12;
      } else {
        exp_fixed = exp;
        exp_precision = exp_original != null ? 0 : 1;
      }
      rounded = Math.round(num / Math.pow(10, exp_fixed - exp_precision));
      rounded /= Math.pow(10, exp_precision);
      rounded = rounded.toFixed(exp_precision);
      return postfix(formatNumber(rounded), exp_fixed);
    };
  };

  poly.format.date = function(format) {
    var level;
    if (_.indexOf(poly["const"].timerange, format) !== -1) {
      level = format;
      if (level === 'second') {
        return function(date) {
          return moment.unix(date).format('h:mm:ss a');
        };
      } else if (level === 'minute') {
        return function(date) {
          return moment.unix(date).format('h:mm a');
        };
      } else if (level === 'hour') {
        return function(date) {
          return moment.unix(date).format('MMM D h a');
        };
      } else if (level === 'day' || level === 'week') {
        return function(date) {
          return moment.unix(date).format('MMM D');
        };
      } else if (level === 'month' || level === '2month' || level === 'quarter' || level === '6month') {
        return function(date) {
          return moment.unix(date).format('YYYY/MM');
        };
      } else if (level === 'year' || level === '2year' || level === '5year' || level === 'decade') {
        return function(date) {
          return moment.unix(date).format('YYYY');
        };
      } else {
        return function(date) {
          return moment.unix(date).format('YYYY');
        };
      }
    } else {
      return function(date) {
        return moment.unix(date).format(format);
      };
    }
  };

  poly.format._number_instance = poly.format.number();

  poly.format.value = function(v) {
    if (_.isNumber(v)) {
      return poly.format._number_instance(v);
    } else {
      return v;
    }
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Impute types from values
*/


(function() {
  var THRESHOLD, compareCat, compareNum;

  THRESHOLD = 0.95;

  poly.type = {};

  poly.type.impute = function(values) {
    var date, m, num, value, _i, _len;
    date = 0;
    num = 0;
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      value = values[_i];
      if (!(value != null)) {
        continue;
      }
      if (!isNaN(value) || !isNaN(value.replace(/\$|\,/g, ''))) {
        num++;
      }
      m = moment(value);
      if ((m != null) && m.isValid()) {
        date++;
      }
    }
    if (num > THRESHOLD * values.length) {
      return 'num';
    }
    if (date > THRESHOLD * values.length) {
      return 'date';
    }
    return 'cat';
  };

  /*
  Parse values into correct types
  */


  poly.type.coerce = function(value, meta) {
    if (meta.type === 'cat') {
      return value;
    } else if (meta.type === 'num') {
      if (!isNaN(value)) {
        return +value;
      } else {
        return +(("" + value).replace(/\$|\,/g, ''));
      }
    } else if (meta.type === 'date') {
      if (meta.format) {
        if (meta.format === 'unix') {
          return moment.unix(value).unix();
        } else {
          return moment(value, meta.format).unix();
        }
      } else {
        return moment(value).unix();
      }
    } else {
      return void 0;
    }
  };

  poly.type.compare = function(type) {
    switch (type) {
      case 'cat':
        return compareCat;
      default:
        return compareNum;
    }
  };

  compareCat = function(a, b) {
    var al, bl;
    if (a === b) {
      return 0;
    }
    if (!_.isString(a)) {
      a = "" + a;
    }
    if (!_.isString(b)) {
      b = "" + b;
    }
    al = a.toLowerCase();
    bl = b.toLowerCase();
    if (al === bl) {
      if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      } else {
        return 0;
      }
    } else {
      if (al < bl) {
        return -1;
      } else if (al > bl) {
        return 1;
      } else {
        return 0;
      }
    }
  };

  compareNum = function(a, b) {
    if (a === b) {
      return 0;
    } else if (a === null) {
      return 1;
    } else if (b === null) {
      return -1;
    } else if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Turns a 'non-strict' spec to a strict one.
See the spec definition for more information.
*/


(function() {

  poly.spec = {};

  poly.spec.toStrictMode = function(spec) {
    var aes, facetvar, i, layer, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    spec = _.clone(spec);
    if (!(spec.layers != null) && spec.layer) {
      spec.layers = [spec.layer];
    }
    if (!(spec.guides != null) && spec.guide) {
      spec.guides = spec.guide;
    }
    if (!(spec.guides != null)) {
      spec.guides = {};
    }
    if (spec.layers) {
      _ref = spec.layers;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        layer = _ref[i];
        _ref1 = poly["const"].aes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          aes = _ref1[_j];
          if (layer[aes] && _.isString(layer[aes])) {
            layer[aes] = {
              "var": layer[aes]
            };
          }
        }
        if (!(layer.sample != null)) {
          layer.sample = 500;
        }
      }
    }
    if (spec.facet) {
      _ref2 = ['var', 'x', 'y'];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        v = _ref2[_k];
        facetvar = spec.facet[v];
        if (facetvar && _.isString(facetvar)) {
          spec.facet[v] = {
            "var": facetvar
          };
        }
      }
    } else {
      spec.facet = {};
    }
    if (!spec.coord) {
      spec.coord = {};
    }
    if (_.isString(spec.dom)) {
      spec.dom = document.getElementById(spec.dom);
    }
    return spec;
  };

  poly.spec.check = function(spec) {
    var id, layer, _i, _len, _ref;
    if (!(spec.layers != null) || spec.layers.length === 0) {
      throw poly.error.defn("No layers are defined in the specification.");
    }
    _ref = spec.layers;
    for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
      layer = _ref[id];
      if (!(layer.data != null)) {
        throw poly.error.defn("Layer " + (id + 1) + " does not have data to plot!");
      }
      if (!layer.data.isData) {
        throw poly.error.defn("Data must be a Polychart Data object.");
      }
    }
    if (!((spec.render != null) && spec.render === false) && !spec.dom) {
      throw poly.error.defn("No DOM element specified. Where to make plot?");
    }
    return spec;
  };

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {

  poly.xhr = function(url, mime, callback) {
    var req;
    req = new XMLHttpRequest;
    if (arguments.length < 3) {
      callback = mime;
      mime = null;
    } else if (mime && req.overrideMimeType) {
      req.overrideMimeType(mime);
    }
    req.open("GET", url, true);
    if (mime) {
      req.setRequestHeader("Accept", mime);
    }
    req.onreadystatechange = function() {
      var arg, s;
      if (req.readyState === 4) {
        s = req.status;
        arg = !s && req.response || s >= 200 && s < 300 || s === 304 ? req : null;
        return callback(arg);
      }
    };
    return req.send(null);
  };

  poly.text = function(url, mime, callback) {
    var ready;
    ready = function(req) {
      return callback(req && req.responseText);
    };
    if (arguments.length < 3) {
      callback = mime;
      mime = null;
    }
    return poly.xhr(url, mime, ready);
  };

  poly.json = function(url, callback) {
    return poly.text(url, "application/json", function(text) {
      return callback(text ? JSON.parse(text) : null);
    });
  };

  poly.dsv = function(delimiter, mimeType) {
    var delimiterCode, dsv, formatRow, formatValue, header, reFormat, reParse;
    reParse = new RegExp("\r\n|[" + delimiter + "\r\n]", "g");
    reFormat = new RegExp("[\"" + delimiter + "\n]");
    delimiterCode = delimiter.charCodeAt(0);
    formatRow = function(row) {
      return row.map(formatValue).join(delimiter);
    };
    formatValue = function(text) {
      var _ref;
      return (_ref = reFormat.test(text)) != null ? _ref : "\"" + text.replace(/\"/g, "\"\"") + {
        "\"": text
      };
    };
    header = null;
    dsv = function(url, callback) {
      return poly.text(url, mimeType, function(text) {
        return callback(text && dsv.parse(text));
      });
    };
    dsv.parse = function(text) {
      return dsv.parseRows(text, function(row, i) {
        var item, j, m, o;
        if (i) {
          o = {};
          j = -1;
          m = header.length;
          while (++j < m) {
            item = row[j];
            o[header[j]] = row[j];
          }
          return o;
        } else {
          header = row;
          return null;
        }
      });
    };
    dsv.parseRows = function(text, f) {
      var EOF, EOL, a, eol, n, rows, t, token;
      EOL = {};
      EOF = {};
      rows = [];
      n = 0;
      t = null;
      eol = null;
      reParse.lastIndex = 0;
      token = function() {
        var c, i, j, m;
        if (reParse.lastIndex >= text.length) {
          return EOF;
        }
        if (eol) {
          eol = false;
          return EOL;
        }
        j = reParse.lastIndex;
        if (text.charCodeAt(j) === 34) {
          i = j;
          while (i++ < text.length) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) {
                break;
              }
              i++;
            }
          }
          reParse.lastIndex = i + 2;
          c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) {
              reParse.lastIndex++;
            }
          } else if (c === 10) {
            eol = true;
          }
          return text.substring(j + 1, i).replace(/""/g, "\"");
        }
        m = reParse.exec(text);
        if (m) {
          eol = m[0].charCodeAt(0) !== delimiterCode;
          return text.substring(j, m.index);
        }
        reParse.lastIndex = text.length;
        return text.substring(j);
      };
      while ((t = token()) !== EOF) {
        a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && !(a = f(a, n++))) {
          continue;
        }
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    return dsv;
  };

  poly.csv = poly.dsv(",", "text/csv");

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var Call, Comma, Const, Expr, Ident, LParen, Literal, RParen, Stream, Symbol, Token, assocsToObj, dedup, dedupOnKey, dictGet, dictGets, expect, extractOps, layerToDataSpec, matchToken, mergeObjLists, parse, parseCall, parseCallArgs, parseConst, parseExpr, parseFail, parseSymbolic, showCall, showList, tag, tokenize, tokenizers, unquote, zip, zipWith, _ref,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  unquote = function(str, quote) {
    var n, _i, _len, _ref;
    n = str.length;
    _ref = ['"', "'"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      quote = _ref[_i];
      if (str[0] === quote && str[n - 1] === quote) {
        return str.slice(1, +(n - 2) + 1 || 9e9);
      }
    }
    return str;
  };

  zipWith = function(op) {
    return function(xs, ys) {
      var ix, xval, _i, _len, _results;
      _results = [];
      for (ix = _i = 0, _len = xs.length; _i < _len; ix = ++_i) {
        xval = xs[ix];
        _results.push(op(xval, ys[ix]));
      }
      return _results;
    };
  };

  zip = zipWith(function(xval, yval) {
    return [xval, yval];
  });

  assocsToObj = function(assocs) {
    var key, obj, val, _i, _len, _ref;
    obj = {};
    for (_i = 0, _len = assocs.length; _i < _len; _i++) {
      _ref = assocs[_i], key = _ref[0], val = _ref[1];
      obj[key] = val;
    }
    return obj;
  };

  dictGet = function(dict, key, defval) {
    if (defval == null) {
      defval = null;
    }
    return (key in dict && dict[key]) || defval;
  };

  dictGets = function(dict, keyVals) {
    var defval, fin, key, val;
    fin = {};
    for (key in keyVals) {
      defval = keyVals[key];
      val = dictGet(dict, key, defval);
      if (val !== null) {
        fin[key] = val;
      }
    }
    return fin;
  };

  mergeObjLists = function(dicts) {
    var dict, fin, key, _i, _len;
    fin = {};
    for (_i = 0, _len = dicts.length; _i < _len; _i++) {
      dict = dicts[_i];
      for (key in dict) {
        fin[key] = dict[key].concat(dictGet(fin, key, []));
      }
    }
    return fin;
  };

  dedup = function(vals, trans) {
    var unique, val, _, _i, _len, _results;
    if (trans == null) {
      trans = function(x) {
        return x;
      };
    }
    unique = {};
    for (_i = 0, _len = vals.length; _i < _len; _i++) {
      val = vals[_i];
      unique[trans(val)] = val;
    }
    _results = [];
    for (_ in unique) {
      val = unique[_];
      _results.push(val);
    }
    return _results;
  };

  dedupOnKey = function(key) {
    return function(vals) {
      return dedup(vals, function(val) {
        return val[key];
      });
    };
  };

  showCall = function(fname, args) {
    return "" + fname + "(" + args + ")";
  };

  showList = function(xs) {
    return "[" + xs + "]";
  };

  Stream = (function() {

    function Stream(src) {
      var val;
      this.buffer = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = src.length; _i < _len; _i++) {
          val = src[_i];
          _results.push(val);
        }
        return _results;
      })()).reverse();
    }

    Stream.prototype.empty = function() {
      return this.buffer.length === 0;
    };

    Stream.prototype.peek = function() {
      if (this.empty()) {
        return null;
      } else {
        return this.buffer[this.buffer.length - 1];
      }
    };

    Stream.prototype.get = function() {
      if (this.empty()) {
        return null;
      } else {
        return this.buffer.pop();
      }
    };

    Stream.prototype.toString = function() {
      return showCall('Stream', showList(__slice.call(this.buffer).reverse()));
    };

    return Stream;

  })();

  Token = (function() {

    Token.Tag = {
      symbol: 'symbol',
      literal: 'literal',
      lparen: '(',
      rparen: ')',
      comma: ','
    };

    function Token(tag) {
      this.tag = tag;
    }

    Token.prototype.toString = function() {
      return "<" + (this.contents().toString()) + ">";
    };

    Token.prototype.contents = function() {
      return [this.tag];
    };

    return Token;

  })();

  Symbol = (function(_super) {

    __extends(Symbol, _super);

    function Symbol(name) {
      this.name = name;
      this.name = unquote(this.name);
      Symbol.__super__.constructor.call(this, Token.Tag.symbol);
    }

    Symbol.prototype.contents = function() {
      return Symbol.__super__.contents.call(this).concat([this.name]);
    };

    return Symbol;

  })(Token);

  Literal = (function(_super) {

    __extends(Literal, _super);

    function Literal(val) {
      this.val = val;
      this.val = unquote(this.val);
      Literal.__super__.constructor.call(this, Token.Tag.literal);
    }

    Literal.prototype.contents = function() {
      return Literal.__super__.contents.call(this).concat([this.val]);
    };

    return Literal;

  })(Token);

  _ref = (function() {
    var _i, _len, _ref, _results;
    _ref = [Token.Tag.lparen, Token.Tag.rparen, Token.Tag.comma];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tag = _ref[_i];
      _results.push(new Token(tag));
    }
    return _results;
  })(), LParen = _ref[0], RParen = _ref[1], Comma = _ref[2];

  tokenizers = [
    [
      /^\(/, function() {
        return LParen;
      }
    ], [
      /^\)/, function() {
        return RParen;
      }
    ], [
      /^,/, function() {
        return Comma;
      }
    ], [
      /^[+-]?(0x[0-9a-fA-F]+|0?\.\d+|[1-9]\d*(\.\d+)?|0)([eE][+-]?\d+)?/, function(val) {
        return new Literal(val);
      }
    ], [
      /^(\w|[^\u0000-\u0080])+|'((\\.)|[^\\'])+'|"((\\.)|[^\\"])+"/, function(name) {
        return new Symbol(name);
      }
    ]
  ];

  matchToken = function(str) {
    var match, op, pat, substr, _i, _len, _ref1;
    for (_i = 0, _len = tokenizers.length; _i < _len; _i++) {
      _ref1 = tokenizers[_i], pat = _ref1[0], op = _ref1[1];
      match = pat.exec(str);
      if (match) {
        substr = match[0];
        return [str.slice(substr.length), op(substr)];
      }
    }
    throw poly.error.defn("There is an error in your specification at " + str);
  };

  tokenize = function(str) {
    var tok, _ref1, _results;
    _results = [];
    while (true) {
      str = str.replace(/^\s+/, '');
      if (!str) {
        break;
      }
      _ref1 = matchToken(str), str = _ref1[0], tok = _ref1[1];
      _results.push(tok);
    }
    return _results;
  };

  Expr = (function() {

    function Expr() {}

    Expr.prototype.toString = function() {
      return showCall(this.constructor.name, this.contents());
    };

    return Expr;

  })();

  Ident = (function(_super) {

    __extends(Ident, _super);

    function Ident(name) {
      this.name = name;
    }

    Ident.prototype.contents = function() {
      return [this.name];
    };

    Ident.prototype.pretty = function() {
      return this.name;
    };

    Ident.prototype.visit = function(visitor) {
      return visitor.ident(this, this.name);
    };

    return Ident;

  })(Expr);

  Const = (function(_super) {

    __extends(Const, _super);

    function Const(val) {
      this.val = val;
    }

    Const.prototype.contents = function() {
      return [this.val];
    };

    Const.prototype.pretty = function() {
      return this.val;
    };

    Const.prototype.visit = function(visitor) {
      return visitor["const"](this, this.val);
    };

    return Const;

  })(Expr);

  Call = (function(_super) {

    __extends(Call, _super);

    function Call(fname, args) {
      this.fname = fname;
      this.args = args;
    }

    Call.prototype.contents = function() {
      return [this.fname, showList(this.args)];
    };

    Call.prototype.pretty = function() {
      var arg;
      return showCall(this.fname, (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.args;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          arg = _ref1[_i];
          _results.push(arg.pretty());
        }
        return _results;
      }).call(this));
    };

    Call.prototype.visit = function(visitor) {
      var arg;
      return visitor.call(this, this.fname, (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.args;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          arg = _ref1[_i];
          _results.push(arg.visit(visitor));
        }
        return _results;
      }).call(this));
    };

    return Call;

  })(Expr);

  expect = function(stream, fail, alts) {
    var express, token, _i, _len, _ref1;
    token = stream.peek();
    if (token !== null) {
      for (_i = 0, _len = alts.length; _i < _len; _i++) {
        _ref1 = alts[_i], tag = _ref1[0], express = _ref1[1];
        if (token.tag === tag) {
          return express(stream);
        }
      }
    }
    return fail(stream);
  };

  parseFail = function(stream) {
    throw poly.error.defn("There is an error in your specification at " + (stream.toString()));
  };

  parse = function(str) {
    var expr, stream;
    stream = new Stream(tokenize(str));
    expr = parseExpr(stream);
    if (stream.peek() !== null) {
      throw poly.error.defn("There is an error in your specification at " + (stream.toString()));
    }
    return expr;
  };

  parseExpr = function(stream) {
    return expect(stream, parseFail, [[Token.Tag.literal, parseConst], [Token.Tag.symbol, parseSymbolic]]);
  };

  parseConst = function(stream) {
    return new Const((stream.get().val));
  };

  parseSymbolic = function(stream) {
    var name;
    name = stream.get().name;
    return expect(stream, (function() {
      return new Ident(name);
    }), [[Token.Tag.lparen, parseCall(name)]]);
  };

  parseCall = function(name) {
    return function(stream) {
      var args;
      stream.get();
      args = expect(stream, parseCallArgs([]), [
        [
          Token.Tag.rparen, function(ts) {
            ts.get();
            return [];
          }
        ]
      ]);
      return new Call(name, args);
    };
  };

  parseCallArgs = function(acc) {
    return function(stream) {
      var arg, args;
      arg = parseExpr(stream);
      args = acc.concat([arg]);
      return expect(stream, parseFail, [
        [
          Token.Tag.rparen, function(ts) {
            ts.get();
            return args;
          }
        ], [
          Token.Tag.comma, function(ts) {
            ts.get();
            return (parseCallArgs(args))(ts);
          }
        ]
      ]);
    };
  };

  extractOps = function(expr) {
    var extractor, results;
    results = {
      trans: [],
      stat: []
    };
    extractor = {
      ident: function(expr, name) {
        return name;
      },
      "const": function(expr, val) {
        return val;
      },
      call: function(expr, fname, args) {
        var opargs, optype, result;
        optype = fname in poly["const"].trans ? 'trans' : fname in poly["const"].stat ? 'stat' : 'none';
        if (optype !== 'none') {
          opargs = poly["const"][optype][fname];
          result = assocsToObj(zip(opargs, args));
          result.name = expr.pretty();
          result[optype] = fname;
          results[optype].push(result);
          return result.name;
        } else {
          throw poly.error.defn("The operation " + fname + " is not recognized. Please check your specifications.");
        }
      }
    };
    expr.visit(extractor);
    return results;
  };

  layerToDataSpec = function(lspec, grouping) {
    var aesthetics, dedupByName, desc, expr, filters, groups, grpvar, key, metas, result, sdesc, select, sexpr, stats, transstat, transstats, ts, val, _i, _len, _ref1, _ref2;
    if (grouping == null) {
      grouping = [];
    }
    filters = {};
    _ref2 = (_ref1 = lspec.filter) != null ? _ref1 : {};
    for (key in _ref2) {
      val = _ref2[key];
      filters[(parse(key)).pretty()] = val;
    }
    grouping = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = grouping.length; _i < _len; _i++) {
        key = grouping[_i];
        _results.push((parse(key["var"])).pretty());
      }
      return _results;
    })();
    aesthetics = _.pick(lspec, poly["const"].aes);
    for (key in aesthetics) {
      if (!('var' in aesthetics[key])) {
        delete aesthetics[key];
      }
    }
    transstat = [];
    select = [];
    groups = [];
    metas = {};
    for (key in aesthetics) {
      desc = aesthetics[key];
      expr = parse(desc["var"]);
      desc["var"] = expr.pretty();
      ts = extractOps(expr);
      transstat.push(ts);
      select.push(desc["var"]);
      if (ts.stat.length === 0) {
        groups.push(desc["var"]);
      }
      if ('sort' in desc) {
        sdesc = dictGets(desc, poly["const"].metas);
        sexpr = parse(sdesc.sort);
        sdesc.sort = sexpr.pretty();
        result = extractOps(sexpr);
        if (result.stat.length !== 0) {
          sdesc.stat = result.stat[0];
        }
        metas[desc["var"]] = sdesc;
      }
    }
    for (_i = 0, _len = grouping.length; _i < _len; _i++) {
      grpvar = grouping[_i];
      expr = parse(grpvar);
      grpvar = expr.pretty();
      ts = extractOps(expr);
      transstat.push(ts);
      select.push(grpvar);
      if (ts.stat.length === 0) {
        groups.push(grpvar);
      } else {
        throw poly.error.defn("Facet variable should not contain statistics!");
      }
    }
    transstats = mergeObjLists(transstat);
    dedupByName = dedupOnKey('name');
    stats = {
      stats: dedupByName(transstats.stat),
      groups: dedup(groups)
    };
    return {
      trans: dedupByName(transstats.trans),
      stats: stats,
      meta: metas,
      select: dedup(select),
      filter: filters
    };
  };

  poly.parser = {
    tokenize: tokenize,
    parse: parse,
    layerToData: layerToDataSpec
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Coordinates
-----------
Defines what coordinate system is used to plot the graph.
*/


(function() {
  var Cartesian, Coordinate, Polar,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    _this = this;

  Coordinate = (function() {

    function Coordinate(spec) {
      var _ref, _ref1, _ref2;
      this.spec = spec;
      if ((_ref = this.spec) == null) {
        this.spec = {};
      }
      this.flip = (_ref1 = this.spec.flip) != null ? _ref1 : false;
      this.scales = null;
      _ref2 = this.flip ? ['y', 'x'] : ['x', 'y'], this.x = _ref2[0], this.y = _ref2[1];
    }

    Coordinate.prototype.make = function(dims) {
      return this.dims = dims;
    };

    Coordinate.prototype.setScales = function(scales) {
      return this.scales = {
        x: scales.x.f,
        y: scales.y.f
      };
    };

    Coordinate.prototype.clipping = function(offset) {
      return [offset.x, offset.y, this.dims.chartWidth, this.dims.chartHeight];
    };

    Coordinate.prototype.getScale = function(aes) {};

    Coordinate.prototype.ranges = function() {};

    return Coordinate;

  })();

  Cartesian = (function(_super) {

    __extends(Cartesian, _super);

    function Cartesian() {
      return Cartesian.__super__.constructor.apply(this, arguments);
    }

    Cartesian.prototype.type = 'cartesian';

    Cartesian.prototype.getScale = function(aes) {
      if (aes === 'x' || aes === 'y') {
        return this.scales[this[aes]];
      } else {
        throw poly.error.input("Coordinates only keep x & y scales");
      }
    };

    Cartesian.prototype.ranges = function() {
      var ranges;
      ranges = {};
      ranges[this.x] = {
        min: 0,
        max: this.dims.chartWidth
      };
      ranges[this.y] = {
        min: this.dims.chartHeight,
        max: 0
      };
      return ranges;
    };

    Cartesian.prototype.axisType = function(aes) {
      return this[aes];
    };

    Cartesian.prototype.getXY = function(mayflip, mark) {
      var point, scalex, scaley;
      if (mayflip) {
        point = {
          x: _.isArray(mark.x) ? _.map(mark.x, this.scales.x) : this.scales.x(mark.x),
          y: _.isArray(mark.y) ? _.map(mark.y, this.scales.y) : this.scales.y(mark.y)
        };
        return {
          x: point[this.x],
          y: point[this.y]
        };
      } else {
        scalex = this.scales[this.x];
        scaley = this.scales[this.y];
        return {
          x: _.isArray(mark.x) ? _.map(mark.x, scalex) : scalex(mark.x),
          y: _.isArray(mark.y) ? _.map(mark.y, scaley) : scaley(mark.y)
        };
      }
    };

    Cartesian.prototype.getAes = function(pixel1, pixel2, reverse) {
      return {
        x: reverse.x(pixel1[this.x], pixel2[this.x]),
        y: reverse.y(pixel1[this.y], pixel2[this.y])
      };
    };

    return Cartesian;

  })(Coordinate);

  Polar = (function(_super) {

    __extends(Polar, _super);

    function Polar() {
      this.getXY = __bind(this.getXY, this);
      return Polar.__super__.constructor.apply(this, arguments);
    }

    Polar.prototype.type = 'polar';

    Polar.prototype.make = function(dims) {
      this.dims = dims;
      this.cx = this.dims.chartWidth / 2;
      return this.cy = this.dims.chartHeight / 2;
    };

    Polar.prototype.getScale = function(aes) {
      if (aes === 'r') {
        return this.scales[this.x];
      } else if (aes === 't') {
        return this.scales[this.y];
      } else {
        throw poly.error.input("Coordinates only keep r & t scales");
      }
    };

    Polar.prototype.ranges = function() {
      var r, ranges, t, _ref;
      _ref = [this.x, this.y], r = _ref[0], t = _ref[1];
      ranges = {};
      ranges[t] = {
        min: 0,
        max: 2 * Math.PI
      };
      ranges[r] = {
        min: 0,
        max: Math.min(this.dims.chartWidth, this.dims.chartHeight) / 2 - 10
      };
      return ranges;
    };

    Polar.prototype.axisType = function(aes) {
      if (this[aes] === 'x') {
        return 'r';
      } else {
        return 't';
      }
    };

    Polar.prototype.getXY = function(mayflip, mark) {
      var getpos, i, ident, points, r, radius, t, theta, x, xpos, y, ypos, _getx, _gety, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3,
        _this = this;
      _getx = function(radius, theta) {
        return _this.cx + radius * Math.cos(theta - Math.PI / 2);
      };
      _gety = function(radius, theta) {
        return _this.cy + radius * Math.sin(theta - Math.PI / 2);
      };
      _ref = [this.x, this.y], r = _ref[0], t = _ref[1];
      if (mayflip) {
        if (_.isArray(mark[r])) {
          points = {
            x: [],
            y: [],
            r: [],
            t: []
          };
          _ref1 = mark[r];
          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
            radius = _ref1[i];
            radius = this.scales[r](radius);
            theta = this.scales[t](mark[t][i]);
            points.x.push(_getx(radius, theta));
            points.y.push(_gety(radius, theta));
            points.r.push(radius);
            points.t.push(theta);
          }
          return points;
        }
        radius = this.scales[r](mark[r]);
        theta = this.scales[t](mark[t]);
        return {
          x: _getx(radius, theta),
          y: _gety(radius, theta),
          r: radius,
          t: theta
        };
      }
      ident = function(obj) {
        return _.isObject(obj) && obj.t === 'scalefn' && obj.f === 'identity';
      };
      getpos = function(x, y) {
        var identx, identy;
        identx = ident(x);
        identy = ident(y);
        if (identx && !identy) {
          return {
            x: x.v,
            y: _gety(_this.scales[r](y), 0)
          };
        } else if (identx && identy) {
          return {
            x: x.v,
            y: y.v
          };
        } else if (!identx && identy) {
          return {
            y: y.v,
            x: _gety(_this.scales[t](x), 0)
          };
        } else {
          radius = _this.scales[r](y);
          theta = _this.scales[t](x);
          return {
            x: _getx(radius, theta),
            y: _gety(radius, theta)
          };
        }
      };
      if (_.isArray(mark.x)) {
        points = {
          x: [],
          y: []
        };
        _ref2 = mark.x;
        for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
          xpos = _ref2[i];
          ypos = mark.y[i];
          _ref3 = getpos(xpos, ypos), x = _ref3.x, y = _ref3.y;
          points.x.push(x);
          points.y.push(y);
        }
        return points;
      }
      return getpos(mark.x, mark.y);
    };

    return Polar;

  })(Coordinate);

  poly.coord = {
    cartesian: function(spec) {
      return new Cartesian(spec);
    },
    polar: function(spec) {
      return new Polar(spec);
    }
  };

  poly.coord.make = function(spec) {
    if (!(spec != null) || !(spec.type != null)) {
      return poly.coord.cartesian();
    }
    switch (spec.type) {
      case 'cartesian':
        return poly.coord.cartesian(spec);
      case 'polar':
        return poly.coord.polar(spec);
      default:
        throw poly.error.defn("No such coordinate type " + spec.type + ".");
    }
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
# CONSTANTS
*/


(function() {
  var CategoricalDomain, DateDomain, NumericDomain, aesthetics, domainMerge, flattenGeoms, makeDomain, makeDomainSet, mergeDomains,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  aesthetics = poly["const"].aes;

  /*
  # GLOBALS
  */


  poly.domain = {};

  /*
  Produce a domain set for each layer based on both the information in each
  layer and the specification of the guides, then merge them into one domain
  set.
  */


  poly.domain.make = function(geoms, metas, guideSpec, strictmode) {
    var domainSets, g, i;
    domainSets = [];
    for (i in geoms) {
      g = geoms[i];
      domainSets.push(makeDomainSet(g.geoms, metas[i], guideSpec, strictmode));
    }
    return poly.domain.merge(domainSets);
  };

  poly.domain.compare = function(domain) {
    if (domain) {
      if (domain.type === 'cat') {
        return function(a, b) {
          a = _.indexOf(domain.levels, a);
          b = _.indexOf(domain.levels, b);
          if (a === -1) {
            return 1;
          } else if (b === -1) {
            return -1;
          } else if (a < b) {
            return -1;
          } else if (a > b) {
            return 1;
          } else {
            return 0;
          }
        };
      } else {
        return poly.type.compare(domain.type);
      }
    } else {
      return function(x) {
        return x;
      };
    }
  };

  /*
  # CLASSES & HELPER
  */


  /*
  Domain classes
  */


  NumericDomain = (function() {

    function NumericDomain(params) {
      this.type = params.type, this.min = params.min, this.max = params.max, this.bw = params.bw;
    }

    return NumericDomain;

  })();

  DateDomain = (function() {

    function DateDomain(params) {
      this.type = params.type, this.min = params.min, this.max = params.max, this.bw = params.bw;
    }

    return DateDomain;

  })();

  CategoricalDomain = (function() {

    function CategoricalDomain(params) {
      this.type = params.type, this.levels = params.levels, this.sorted = params.sorted;
    }

    return CategoricalDomain;

  })();

  /*
  Public-ish interface for making different domain types
  */


  makeDomain = function(params) {
    switch (params.type) {
      case 'num':
        return new NumericDomain(params);
      case 'date':
        return new DateDomain(params);
      case 'cat':
        return new CategoricalDomain(params);
    }
  };

  /*
  Make a domain set. A domain set is an associate array of domains, with the
  keys being aesthetics
  */


  makeDomainSet = function(geoms, metas, guideSpec, strictmode) {
    var aes, bw, domain, fromspec, max, meta, min, values, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    domain = {};
    for (aes in metas) {
      meta = metas[aes];
      if (__indexOf.call(poly["const"].noDomain, aes) >= 0) {
        continue;
      }
      if (strictmode) {
        domain[aes] = makeDomain(guideSpec[aes]);
      } else {
        values = flattenGeoms(geoms, aes);
        fromspec = function(item) {
          if (guideSpec[aes] != null) {
            return guideSpec[aes][item];
          } else {
            return null;
          }
        };
        switch (meta.type) {
          case 'num':
            bw = (_ref = fromspec('bw')) != null ? _ref : meta.bw;
            min = (_ref1 = fromspec('min')) != null ? _ref1 : _.min(values);
            max = (_ref2 = fromspec('max')) != null ? _ref2 : _.max(values) + (bw != null ? bw : 0);
            domain[aes] = makeDomain({
              type: 'num',
              min: min,
              max: max,
              bw: bw
            });
            break;
          case 'date':
            bw = (_ref3 = fromspec('bw')) != null ? _ref3 : meta.bw;
            min = (_ref4 = fromspec('min')) != null ? _ref4 : _.min(values);
            max = fromspec('max');
            if (!(max != null)) {
              max = _.max(values);
              max = bw === 'week' ? moment.unix(max).add('days', 7).unix() : bw === 'decade' ? moment.unix(max).add('years', 10).unix() : moment.unix(max).add(bw + 's', 1).unix();
            }
            domain[aes] = makeDomain({
              type: 'date',
              min: min,
              max: max,
              bw: bw
            });
            break;
          case 'cat':
            domain[aes] = makeDomain({
              type: 'cat',
              levels: (_ref5 = (_ref6 = fromspec('levels')) != null ? _ref6 : meta.levels) != null ? _ref5 : _.uniq(values),
              sorted: (_ref7 = (_ref8 = fromspec('levels')) != null ? _ref8 : meta.sorted) != null ? _ref7 : false
            });
        }
      }
    }
    return domain;
  };

  /*
  VERY preliminary flatten function. Need to optimize
  */


  flattenGeoms = function(geoms, aes) {
    var geom, k, l, mark, values, _ref;
    values = [];
    for (k in geoms) {
      geom = geoms[k];
      _ref = geom.marks;
      for (l in _ref) {
        mark = _ref[l];
        values = values.concat(poly.flatten(mark[aes]));
      }
    }
    return values;
  };

  /*
  Merge an array of domain sets: i.e. merge all the domains that shares the
  same aesthetics.
  */


  poly.domain.merge = function(domainSets) {
    var aes, domains, merged, _i, _len;
    merged = {};
    for (_i = 0, _len = aesthetics.length; _i < _len; _i++) {
      aes = aesthetics[_i];
      domains = _.without(_.pluck(domainSets, aes), void 0);
      if (domains.length > 0) {
        merged[aes] = mergeDomains(domains);
      }
    }
    return merged;
  };

  /*
  Helper for merging domains of the same type. Two domains of the same type
  can be merged if they share the same properties:
   - For numeric/date variables all domains must have the same binwidth parameter
   - For categorial variables, sorted domains must have any categories in common
  */


  domainMerge = {
    'num': function(domains) {
      var bw, max, min, _ref;
      bw = _.compact(_.uniq(_.map(domains, function(d) {
        return d.bw;
      })));
      if (bw.length > 1) {
        throw poly.error.data("Not all layers have the same binwidth.");
      }
      bw = (_ref = bw[0]) != null ? _ref : void 0;
      min = _.min(_.map(domains, function(d) {
        return d.min;
      }));
      max = _.max(_.map(domains, function(d) {
        return d.max;
      }));
      return makeDomain({
        type: 'num',
        min: min,
        max: max,
        bw: bw
      });
    },
    'date': function(domains) {
      var bw, max, min, _ref;
      bw = _.compact(_.uniq(_.map(domains, function(d) {
        return d.bw;
      })));
      if (bw.length > 1) {
        throw poly.error.data("Not all layers have the same binwidth.");
      }
      bw = (_ref = bw[0]) != null ? _ref : void 0;
      min = _.min(_.map(domains, function(d) {
        return d.min;
      }));
      max = _.max(_.map(domains, function(d) {
        return d.max;
      }));
      return makeDomain({
        type: 'date',
        min: min,
        max: max,
        bw: bw
      });
    },
    'cat': function(domains) {
      var add, d, l, levels, sortedLevels, unsortedLevels, _i, _j, _len, _len1;
      sortedLevels = [];
      for (_i = 0, _len = domains.length; _i < _len; _i++) {
        d = domains[_i];
        if (d.sorted) {
          add = true;
          for (_j = 0, _len1 = sortedLevels.length; _j < _len1; _j++) {
            l = sortedLevels[_j];
            if (_.isEqual(l, d.levels)) {
              add = false;
            }
          }
          if (add) {
            sortedLevels.push(d.levels);
          }
        }
      }
      unsortedLevels = _.chain(domains).filter(function(d) {
        return !d.sorted;
      }).map(function(d) {
        return d.levels;
      }).value();
      if (sortedLevels.length > 1 && _.intersection.apply(this, sortedLevels)) {
        throw poly.error.data("You are trying to combine incompatible sorted domains in the same axis.");
      }
      sortedLevels = [_.flatten(sortedLevels, true)];
      levels = _.union.apply(this, sortedLevels.concat(unsortedLevels));
      if (sortedLevels[0].length === 0) {
        levels = levels.sort();
      }
      return makeDomain({
        type: 'cat',
        levels: levels,
        sorted: sortedLevels[0].length !== 0
      });
    }
  };

  /*
  Merge an array of domains: Two domains can be merged if they are of the
  same type, and they share certain properties.
  */


  mergeDomains = function(domains) {
    var types;
    types = _.uniq(_.map(domains, function(d) {
      return d.type;
    }));
    if (types.length > 1) {
      throw poly.error.data("You are trying to merge data of different types in the same axis or legend.");
    }
    return domainMerge[types[0]](domains);
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Tick Generation
---------------
Helper functions to legends & axes for generating ticks
*/


(function() {
  var Tick, getStep, tickFactory, tickValues;

  poly.tick = {};

  /*
  Produce an associate array of aesthetics to tick objects.
  */


  poly.tick.make = function(domain, guideSpec, type) {
    var formatter, i, next, numticks, prev, step, t, tickfn, tickobjs, ticks, _i, _ref, _ref1, _ref2;
    step = null;
    if (guideSpec.ticks != null) {
      ticks = guideSpec.ticks;
    } else {
      numticks = (_ref = guideSpec.numticks) != null ? _ref : 5;
      _ref1 = tickValues[type](domain, numticks), ticks = _ref1.ticks, step = _ref1.step;
    }
    if (guideSpec.labels) {
      formatter = function(x) {
        var _ref2;
        return (_ref2 = guideSpec.labels[x]) != null ? _ref2 : x;
      };
    } else if (guideSpec.formatter) {
      formatter = guideSpec.formatter;
    } else {
      formatter = poly.format(type, step);
    }
    tickobjs = {};
    tickfn = tickFactory(type, formatter);
    if (ticks) {
      for (i = _i = 0, _ref2 = ticks.length - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        prev = i === 0 ? null : ticks[i - 1];
        next = i === ticks.length - 1 ? null : ticks[i + 1];
        t = ticks[i];
        tickobjs[t] = tickfn(t, prev, next);
      }
    }
    return tickobjs;
  };

  /*
  # CLASSES & HELPERS
  */


  /*
  Tick Object.
  */


  Tick = (function() {

    function Tick(params) {
      this.location = params.location, this.value = params.value, this.index = params.index, this.evtData = params.evtData;
    }

    return Tick;

  })();

  /*
  Helper function for creating a function that creates ticks
  */


  tickFactory = function(type, formatter) {
    var i;
    i = 0;
    return function(value, prev, next) {
      var evtData;
      if (type === 'cat') {
        evtData = {
          "in": value
        };
      } else {
        evtData = {};
        if (prev != null) {
          evtData.ge = prev;
        }
        if (next != null) {
          evtData.le = next;
        }
      }
      return new Tick({
        location: value,
        value: formatter(value),
        index: i++,
        evtData: evtData
      });
    };
  };

  /*
  Helper function for determining the size of each "step" (distance between
  ticks) for numeric scales
  */


  getStep = function(span, numticks) {
    var error, step;
    step = Math.pow(10, Math.floor(Math.log(span / numticks) / Math.LN10));
    error = numticks / span * step;
    if (error < 0.15) {
      step *= 10;
    } else if (error <= 0.35) {
      step *= 5;
    } else if (error <= 0.75) {
      step *= 2;
    }
    return step;
  };

  /*
  Function for calculating the location of ticks.
  */


  tickValues = {
    'none': function() {
      return {};
    },
    'cat': function(domain, numticks) {
      var i, item, len, step, ticks, _i, _len, _ref;
      len = domain.levels.length;
      step = Math.max(1, Math.round(len / numticks));
      ticks = [];
      _ref = domain.levels;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (i % step === 0) {
          ticks.push(item);
        }
      }
      return {
        ticks: ticks
      };
    },
    'num': function(domain, numticks) {
      var max, min, step, ticks, tmp;
      min = domain.min, max = domain.max;
      step = getStep(max - min, numticks);
      tmp = Math.ceil(min / step) * step;
      ticks = [];
      while (tmp < max) {
        ticks.push(tmp);
        tmp += step;
      }
      return {
        ticks: ticks,
        step: Math.floor(Math.log(step) / Math.LN10)
      };
    },
    'num-log': function(domain, numticks) {
      var exp, lg, lgmax, lgmin, max, min, num, step, tmp;
      min = domain.min, max = domain.max;
      lg = function(v) {
        return Math.log(v) / Math.LN10;
      };
      exp = function(v) {
        return Math.exp(v * Math.LN10);
      };
      lgmin = Math.max(lg(min), 0);
      lgmax = lg(max);
      step = getStep(lgmax - lgmin, numticks);
      tmp = Math.ceil(lgmin / step) * step;
      while (tmp < (lgmax + poly["const"].epsilon)) {
        if (tmp % 1 !== 0 && tmp % 1 <= 0.1) {
          tmp += step;
          continue;
        } else if (tmp % 1 > poly["const"].epsilon) {
          num = Math.floor(tmp) + lg(10 * (tmp % 1));
          if (num % 1 === 0) {
            tmp += step;
            continue;
          }
        }
        num = exp(num);
        if (num < min || num > max) {
          tmp += step;
          continue;
        }
        ticks.push(num);
      }
      return {
        ticks: ticks
      };
    },
    'date': function(domain, numticks) {
      var current, max, min, momentjsStep, step, ticks;
      min = domain.min, max = domain.max;
      step = (max - min) / numticks;
      step = step < 1.4 * 1 ? 'second' : step < 1.4 * 60 ? 'minute' : step < 1.4 * 60 * 60 ? 'hour' : step < 1.4 * 24 * 60 * 60 ? 'day' : step < 1.4 * 7 * 24 * 60 * 60 ? 'week' : step < 1.4 * 30 * 24 * 60 * 60 ? 'month' : step < 1.4 * 30 * 24 * 60 * 60 * 2 ? '2month' : step < 1.4 * 30 * 24 * 60 * 60 * 4 ? 'quarter' : step < 1.4 * 30 * 24 * 60 * 60 * 6 ? '6month' : step < 1.4 * 24 * 60 * 60 * 365 ? 'year' : step < 1.4 * 24 * 60 * 60 * 365 * 2 ? '2year' : step < 1.4 * 24 * 60 * 60 * 365 * 5 ? '5year' : 'decade';
      ticks = [];
      current = moment.unix(min).startOf(step);
      momentjsStep = (function() {
        switch (step) {
          case '2month':
            return ['months', 2];
          case 'quarter':
            return ['months', 4];
          case '6month':
            return ['months', 6];
          case '2year':
            return ['years', 2];
          case '5year':
            return ['years', 5];
          case 'decade':
            return ['years', 10];
          default:
            return [step + 's', 1];
        }
      })();
      if (current.unix() < min) {
        current.add(momentjsStep[0], momentjsStep[1]);
      }
      while (current.unix() < max) {
        ticks.push(current.unix());
        current.add(momentjsStep[0], momentjsStep[1]);
      }
      return {
        ticks: ticks,
        step: step
      };
    }
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Title (Guide)
---------
Classes related to the generation and management of titles.

Titles are guides that is a single text: i.e. main titles and
axis & facet labels.

TODO: This is still the OLD version of Title that does not make
use of Geometry/Renderable. This is okay for now since titles are
so simple, but not scalable.
*/


(function() {
  var Title, TitleFacet, TitleH, TitleMain, TitleV, sf, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  sf = poly["const"].scaleFns;

  Title = (function(_super) {

    __extends(Title, _super);

    function Title() {
      this.render = __bind(this.render, this);

      this.make = __bind(this.make, this);
      this.position = 'none';
      this.titletext = null;
      this.title = null;
    }

    Title.prototype.make = function(params) {
      var guideSpec, option, position, title, _ref,
        _this = this;
      guideSpec = params.guideSpec, title = params.title, position = params.position;
      option = function(item, def) {
        var _ref;
        return (_ref = guideSpec[item]) != null ? _ref : def;
      };
      this.titletext = option('title', title);
      this.position = (_ref = option('position', position)) != null ? _ref : this.defaultPosition;
      if (this.position === 'out') {
        return this.position = 'bottom';
      }
    };

    Title.prototype.render = function(renderer, dim, offset) {
      if (this.position !== 'none') {
        if (this.title != null) {
          renderer.remove(this.title);
        }
        return this.title = renderer.add(this._makeTitle(dim, offset));
      } else if (this.title != null) {
        return renderer.remove(this.title);
      }
    };

    Title.prototype.dispose = function(renderer) {
      renderer.remove(this.title);
      return this.title = null;
    };

    Title.prototype._makeTitle = function() {
      throw poly.error.impl();
    };

    Title.prototype.getDimension = function() {
      var offset;
      offset = {};
      if (this.position !== 'none') {
        offset[this.position] = 10;
      }
      return offset;
    };

    return Title;

  })(poly.Guide);

  TitleH = (function(_super) {

    __extends(TitleH, _super);

    function TitleH() {
      return TitleH.__super__.constructor.apply(this, arguments);
    }

    TitleH.prototype.defaultPosition = 'bottom';

    TitleH.prototype._makeTitle = function(dim, offset) {
      var x, y, _ref, _ref1;
      y = this.position === 'top' ? dim.paddingTop + dim.guideTop - ((_ref = offset.top) != null ? _ref : 0) - 2 : dim.height - dim.paddingBottom - dim.guideBottom + ((_ref1 = offset.bottom) != null ? _ref1 : 0);
      x = dim.paddingLeft + dim.guideLeft + (dim.width - dim.paddingLeft - dim.guideLeft - dim.paddingRight - dim.guideRight) / 2;
      return {
        type: 'text',
        x: sf.identity(x),
        y: sf.identity(y),
        text: this.titletext,
        'text-anchor': 'middle'
      };
    };

    return TitleH;

  })(Title);

  TitleV = (function(_super) {

    __extends(TitleV, _super);

    function TitleV() {
      return TitleV.__super__.constructor.apply(this, arguments);
    }

    TitleV.prototype.defaultPosition = 'left';

    TitleV.prototype._makeTitle = function(dim, offset) {
      var x, y, _ref, _ref1;
      x = this.position === 'left' ? dim.paddingLeft + dim.guideLeft - ((_ref = offset.left) != null ? _ref : 0) - 7 : dim.width - dim.paddingRight - dim.guideRight + ((_ref1 = offset.right) != null ? _ref1 : 0);
      y = dim.paddingTop + dim.guideTop + (dim.height - dim.paddingTop - dim.guideTop - dim.paddingBottom - dim.guideBottom) / 2;
      return {
        type: 'text',
        x: sf.identity(x),
        y: sf.identity(y),
        text: this.titletext,
        'text-anchor': 'middle',
        transform: 'r270'
      };
    };

    return TitleV;

  })(Title);

  TitleMain = (function(_super) {

    __extends(TitleMain, _super);

    function TitleMain() {
      return TitleMain.__super__.constructor.apply(this, arguments);
    }

    TitleMain.prototype._makeTitle = function(dim, offset) {
      var x, y;
      x = dim.width / 2;
      y = 20;
      return {
        type: 'text',
        x: sf.identity(x),
        y: sf.identity(y),
        text: this.titletext,
        'font-size': '13px',
        'font-weight': 'bold',
        'text-anchor': 'middle'
      };
    };

    return TitleMain;

  })(Title);

  TitleFacet = (function(_super) {

    __extends(TitleFacet, _super);

    function TitleFacet() {
      this.render = __bind(this.render, this);

      this.make = __bind(this.make, this);
      return TitleFacet.__super__.constructor.apply(this, arguments);
    }

    TitleFacet.prototype.make = function(params) {
      var title;
      title = params.title;
      return this.titletext = title;
    };

    TitleFacet.prototype.render = function(renderer, dim, offset) {
      if (this.title != null) {
        return this.title = renderer.animate(this.title, this._makeTitle(dim, offset));
      } else {
        return this.title = renderer.add(this._makeTitle(dim, offset));
      }
    };

    TitleFacet.prototype._makeTitle = function(dim, offset) {
      return {
        type: 'text',
        x: sf.identity(offset.x + dim.chartWidth / 2),
        y: sf.identity(offset.y - 7),
        text: this.titletext,
        'text-anchor': 'middle'
      };
    };

    return TitleFacet;

  })(Title);

  if ((_ref = poly.guide) == null) {
    poly.guide = {};
  }

  poly.guide.title = function(type) {
    if (type === 'y' || type === 'r') {
      return new TitleV();
    } else if (type === 'main') {
      return new TitleMain();
    } else if (type === 'facet') {
      return new TitleFacet();
    } else {
      return new TitleH();
    }
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Axis (Guide)
---------
Classes related to the generation and management of axes.

Like layers, Axis class (and classes that extends Guide) takes in required
input about the data domain, scales, etc and produces abstract geometrical
objects that can later be rendered using Geometry class.
*/


(function() {
  var Axes, Axis, RAxis, TAxis, XAxis, YAxis, sf, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  sf = poly["const"].scaleFns;

  /*
  Renders and manages multiple axes, plot over multiple facets.
  */


  Axes = (function(_super) {

    __extends(Axes, _super);

    function Axes() {
      this.axesGeoms = {};
    }

    Axes.prototype.make = function(params) {
      var _ref, _ref1, _ref2, _ref3;
      this.domains = params.domains, this.coord = params.coord, this.scales = params.scales, this.specs = params.specs, this.labels = params.labels;
      return this.axes = {
        x: poly.guide.axis(this.coord.axisType('x'), {
          domain: this.domains.x,
          type: this.scales.x.tickType(),
          guideSpec: (_ref = this.specs.x) != null ? _ref : {},
          key: (_ref1 = this.labels.x) != null ? _ref1 : 'x'
        }),
        y: poly.guide.axis(this.coord.axisType('y'), {
          domain: this.domains.y,
          type: this.scales.y.tickType(),
          guideSpec: (_ref2 = this.specs.y) != null ? _ref2 : {},
          key: (_ref3 = this.labels.y) != null ? _ref3 : 'y'
        })
      };
    };

    Axes.prototype.getDimension = function(dims) {
      var axis, d, key, offset, _ref;
      offset = {};
      _ref = this.axes;
      for (key in _ref) {
        axis = _ref[key];
        d = axis.getDimension();
        if (d.position === 'left') {
          offset.left = d.width;
        } else if (d.position === 'right') {
          offset.right = d.width;
        } else if (d.position === 'bottom') {
          offset.bottom = d.height;
        } else if (d.position === 'top') {
          offset.top = d.height;
        }
      }
      return offset;
    };

    Axes.prototype.render = function(dims, renderer, facet) {
      var added, aes, axis, axisDim, deleted, drawx, drawy, indices, k, kept, key, offset, override, pts, r, xoverride, yoverride, _base, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      indices = _.keys(facet.indices);
      _ref = poly.compare(_.keys(this.axesGeoms), indices), deleted = _ref.deleted, kept = _ref.kept, added = _ref.added;
      for (_i = 0, _len = deleted.length; _i < _len; _i++) {
        key = deleted[_i];
        _ref1 = this.axesGeoms[key];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          axis = _ref1[_j];
          axis.dispose();
        }
      }
      axisDim = {
        top: 0,
        left: 0,
        right: dims.chartWidth,
        bottom: dims.chartHeight,
        width: dims.chartWidth,
        height: dims.chartHeight
      };
      drawx = facet.edge(this.axes.x.position);
      drawy = facet.edge(this.axes.y.position);
      xoverride = {
        renderLabel: false,
        renderTick: false
      };
      yoverride = {
        renderLabel: false,
        renderTick: false
      };
      if (this.axes.x.type === 'r') {
        xoverride.renderLine = false;
      }
      if (this.axes.y.type === 'r') {
        yoverride.renderLine = false;
      }
      _results = [];
      for (_k = 0, _len2 = indices.length; _k < _len2; _k++) {
        key = indices[_k];
        offset = facet.getOffset(dims, key);
        if ((_ref2 = (_base = this.axesGeoms)[key]) == null) {
          _base[key] = {
            x: new poly.Geometry(),
            y: new poly.Geometry()
          };
        }
        r = renderer(offset, false, false);
        override = drawx(key) ? {} : xoverride;
        this.axesGeoms[key].x.set(this.axes.x.calculate(axisDim, this.coord, override));
        this.axesGeoms[key].x.render(r);
        override = drawy(key) ? {} : yoverride;
        this.axesGeoms[key].y.set(this.axes.y.calculate(axisDim, this.coord, override));
        this.axesGeoms[key].y.render(r);
        _results.push((function() {
          var _l, _len3, _ref3, _results1;
          _ref3 = ['x', 'y'];
          _results1 = [];
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            aes = _ref3[_l];
            _results1.push((function() {
              var _ref4, _results2;
              _ref4 = this.axesGeoms[key][aes].pts;
              _results2 = [];
              for (k in _ref4) {
                pts = _ref4[k];
                if (pts.grid) {
                  _results2.push(pts.grid.toBack());
                } else {
                  _results2.push(void 0);
                }
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Axes.prototype.dispose = function(renderer) {
      var axes, key, _ref;
      _ref = this.axesGeoms;
      for (key in _ref) {
        axes = _ref[key];
        axes.x.dispose();
        axes.y.dispose();
      }
      return this.axesGeoms = {};
    };

    return Axes;

  })(poly.GuideSet);

  /*
  Abstract class for a single axis.
  */


  Axis = (function(_super) {

    __extends(Axis, _super);

    function Axis(params) {
      this.calculate = __bind(this.calculate, this);

      var domain, guideSpec, key, option, type, _ref,
        _this = this;
      domain = params.domain, type = params.type, guideSpec = params.guideSpec, key = params.key;
      option = function(item, def) {
        var _ref;
        return (_ref = guideSpec[item]) != null ? _ref : def;
      };
      this.position = option('position', this.defaultPosition);
      if (_ref = this.position, __indexOf.call(this.validPositions, _ref) < 0) {
        throw poly.error.defn("X-axis position can't be " + this.position + ".");
      }
      this.titletext = option('title', key);
      this.renderTick = option('renderTick', true);
      this.renderGrid = option('renderGrid', true);
      this.renderLabel = option('renderLabel', true);
      this.renderLine = option('renderLine', true);
      this.ticks = poly.tick.make(domain, guideSpec, type);
      this.maxwidth = _.max(_.map(this.ticks, function(t) {
        return poly.strSize(t.value);
      }));
      this.maxwidth = Math.max(this.maxwidth, 0);
    }

    Axis.prototype.calculate = function(axisDim, coord, override) {
      var geoms, key, marks, tick, _ref, _ref1, _ref2, _ref3;
      this.coord = coord;
      if (this.position === "none") {
        return {};
      }
      if (override == null) {
        override = {};
      }
      axisDim.centerx = axisDim.left + axisDim.width / 2;
      axisDim.centery = axisDim.top + axisDim.height / 2;
      axisDim.radius = Math.min(axisDim.width, axisDim.height) / 2 - 10;
      geoms = {};
      if (this.renderLine) {
        geoms['line'] = {
          marks: {
            0: this._renderline(axisDim)
          }
        };
      }
      _ref = this.ticks;
      for (key in _ref) {
        tick = _ref[key];
        marks = {};
        if (this.renderTick && ((_ref1 = override.renderTick) != null ? _ref1 : true)) {
          marks.tick = this._makeTick(axisDim, tick);
        }
        if (this.renderLabel && ((_ref2 = override.renderLabel) != null ? _ref2 : true)) {
          marks.text = this._makeLabel(axisDim, tick);
        }
        if (this.renderGrid && ((_ref3 = override.renderGrid) != null ? _ref3 : true)) {
          marks.grid = this._makeGrid(axisDim, tick);
        }
        geoms[key] = {
          marks: marks
        };
      }
      return geoms;
    };

    Axis.prototype._makeTick = function(obj) {
      if (!obj) {
        throw poly.error.impl();
      }
      obj.type = 'path';
      obj.stroke = sf.identity('black');
      return obj;
    };

    Axis.prototype._makeLabel = function(obj) {
      if (!obj) {
        throw poly.error.impl();
      }
      obj.type = 'text';
      return obj;
    };

    Axis.prototype._makeGrid = function(obj) {
      if (!obj) {
        throw poly.error.impl();
      }
      obj.stroke = '#CCC';
      obj['stroke-dasharray'] = '- ';
      obj['stroke-dashoffset'] = 3;
      return obj;
    };

    return Axis;

  })(poly.Guide);

  XAxis = (function(_super) {

    __extends(XAxis, _super);

    function XAxis() {
      return XAxis.__super__.constructor.apply(this, arguments);
    }

    XAxis.prototype.type = 'x';

    XAxis.prototype.defaultPosition = 'bottom';

    XAxis.prototype.validPositions = ['top', 'bottom', 'none'];

    XAxis.prototype._renderline = function(axisDim) {
      var x1, x2, y;
      if (this.position === 'top') {
        y = sf.identity(axisDim.top);
      } else {
        y = sf.identity(axisDim.bottom);
      }
      x1 = sf.identity(axisDim.left);
      x2 = sf.identity(axisDim.left + axisDim.width);
      return {
        type: 'path',
        y: [y, y],
        x: [x1, x2],
        stroke: sf.identity('black')
      };
    };

    XAxis.prototype._makeTick = function(axisDim, tick) {
      var y1, y2;
      if (this.position === 'top') {
        y1 = sf.identity(axisDim.top);
        y2 = sf.identity(axisDim.top - 5);
      } else {
        y1 = sf.identity(axisDim.bottom);
        y2 = sf.identity(axisDim.bottom + 5);
      }
      return XAxis.__super__._makeTick.call(this, {
        x: [tick.location, tick.location],
        y: [y1, y2]
      });
    };

    XAxis.prototype._makeLabel = function(axisDim, tick) {
      var y;
      if (this.position === 'top') {
        y = sf.identity(axisDim.top - 15);
      } else {
        y = sf.identity(axisDim.bottom + 15);
      }
      return XAxis.__super__._makeLabel.call(this, {
        x: tick.location,
        y: y,
        text: tick.value,
        'text-anchor': 'middle'
      });
    };

    XAxis.prototype._makeGrid = function(axisDim, tick) {
      var y1, y2;
      y1 = sf.identity(axisDim.top);
      y2 = sf.identity(axisDim.bottom);
      return XAxis.__super__._makeGrid.call(this, {
        type: 'path',
        x: [tick.location, tick.location],
        y: [y1, y2]
      });
    };

    XAxis.prototype.getDimension = function() {
      var _ref;
      return {
        position: (_ref = this.position) != null ? _ref : 'bottom',
        height: 30,
        width: 'all'
      };
    };

    return XAxis;

  })(Axis);

  YAxis = (function(_super) {

    __extends(YAxis, _super);

    function YAxis() {
      return YAxis.__super__.constructor.apply(this, arguments);
    }

    YAxis.prototype.type = 'y';

    YAxis.prototype.defaultPosition = 'left';

    YAxis.prototype.validPositions = ['left', 'right', 'none'];

    YAxis.prototype._renderline = function(axisDim) {
      var x, y1, y2;
      if (this.position === 'left') {
        x = sf.identity(axisDim.left);
      } else {
        x = sf.identity(axisDim.right);
      }
      y1 = sf.identity(axisDim.top);
      y2 = sf.identity(axisDim.top + axisDim.height);
      return {
        type: 'path',
        x: [x, x],
        y: [y1, y2],
        stroke: sf.identity('black')
      };
    };

    YAxis.prototype._makeTick = function(axisDim, tick) {
      var x1, x2;
      if (this.position === 'left') {
        x1 = sf.identity(axisDim.left);
        x2 = sf.identity(axisDim.left - 5);
      } else {
        x1 = sf.identity(axisDim.right);
        x2 = sf.identity(axisDim.right + 5);
      }
      return YAxis.__super__._makeTick.call(this, {
        x: [x1, x2],
        y: [tick.location, tick.location]
      });
    };

    YAxis.prototype._makeLabel = function(axisDim, tick) {
      var x;
      if (this.position === 'left') {
        x = sf.identity(axisDim.left - 7);
      } else {
        x = sf.identity(axisDim.right + 7);
      }
      return YAxis.__super__._makeLabel.call(this, {
        x: x,
        y: tick.location,
        text: tick.value,
        'text-anchor': this.position === 'left' ? 'end' : 'start'
      });
    };

    YAxis.prototype._makeGrid = function(axisDim, tick) {
      var x1, x2;
      x1 = sf.identity(axisDim.left);
      x2 = sf.identity(axisDim.right);
      return YAxis.__super__._makeGrid.call(this, {
        type: 'path',
        y: [tick.location, tick.location],
        x: [x1, x2]
      });
    };

    YAxis.prototype.getDimension = function() {
      var _ref;
      return {
        position: (_ref = this.position) != null ? _ref : 'right',
        height: 'all',
        width: 5 + this.maxwidth
      };
    };

    return YAxis;

  })(Axis);

  RAxis = (function(_super) {

    __extends(RAxis, _super);

    function RAxis() {
      return RAxis.__super__.constructor.apply(this, arguments);
    }

    RAxis.prototype.type = 'r';

    RAxis.prototype.defaultPosition = 'left';

    RAxis.prototype.validPositions = ['left', 'right', 'none'];

    RAxis.prototype._renderline = function(axisDim) {
      var x, y1, y2;
      x = sf.identity(axisDim.left);
      y1 = sf.identity(axisDim.top);
      y2 = sf.identity(axisDim.top + axisDim.height / 2);
      return {
        type: 'path',
        x: [x, x],
        y: [y1, y2],
        stroke: sf.identity('black')
      };
    };

    RAxis.prototype._makeTick = function(axisDim, tick) {
      return RAxis.__super__._makeTick.call(this, {
        x: [sf.identity(axisDim.left), sf.identity(axisDim.left - 5)],
        y: [tick.location, tick.location]
      });
    };

    RAxis.prototype._makeLabel = function(axisDim, tick) {
      return RAxis.__super__._makeLabel.call(this, {
        x: sf.identity(axisDim.left - 7),
        y: tick.location,
        text: tick.value,
        'text-anchor': 'end'
      });
    };

    RAxis.prototype._makeGrid = function(axisDim, tick) {
      return RAxis.__super__._makeGrid.call(this, {
        type: 'circle',
        x: sf.identity(axisDim.centerx),
        y: sf.identity(axisDim.centery),
        size: sf.identity(this.coord.getScale('r')(tick.location)),
        color: sf.identity('none'),
        'fill-opacity': 0,
        'stroke-width': 1
      });
    };

    RAxis.prototype.getDimension = function() {
      return {
        position: 'left',
        height: 'all',
        width: 5 + this.maxwidth
      };
    };

    return RAxis;

  })(Axis);

  TAxis = (function(_super) {

    __extends(TAxis, _super);

    function TAxis() {
      return TAxis.__super__.constructor.apply(this, arguments);
    }

    TAxis.prototype.type = 't';

    TAxis.prototype.defaultPosition = 'out';

    TAxis.prototype.validPositions = ['out', 'none'];

    TAxis.prototype._renderline = function(axisDim) {
      return {
        type: 'circle',
        x: sf.identity(axisDim.centerx),
        y: sf.identity(axisDim.centery),
        size: sf.identity(axisDim.radius),
        color: sf.identity('none'),
        stroke: sf.identity('black'),
        'stroke-width': 1
      };
    };

    TAxis.prototype._makeTick = function(axisDim, tick) {
      return TAxis.__super__._makeTick.call(this, {
        x: [tick.location, tick.location],
        y: [sf.max(0), sf.max(3)]
      });
    };

    TAxis.prototype._makeLabel = function(axisDim, tick) {
      return TAxis.__super__._makeLabel.call(this, {
        x: tick.location,
        y: sf.max(12),
        text: tick.value,
        'text-anchor': 'middle'
      });
    };

    TAxis.prototype._makeGrid = function(axisDim, tick) {
      var theta, x1, x2, y1, y2;
      x1 = sf.identity(axisDim.centerx);
      y1 = sf.identity(axisDim.centery);
      theta = this.coord.getScale('t')(tick.location) - Math.PI / 2;
      x2 = sf.identity(axisDim.centerx + axisDim.radius * Math.cos(theta));
      y2 = sf.identity(axisDim.centery + axisDim.radius * Math.sin(theta));
      return TAxis.__super__._makeGrid.call(this, {
        type: 'path',
        y: [y1, y2],
        x: [x1, x2]
      });
    };

    TAxis.prototype.getDimension = function() {
      return {};
    };

    return TAxis;

  })(Axis);

  if ((_ref = poly.guide) == null) {
    poly.guide = {};
  }

  poly.guide.axis = function(type, params) {
    if (type === 'x') {
      return new XAxis(params);
    } else if (type === 'y') {
      return new YAxis(params);
    } else if (type === 'r') {
      return new RAxis(params);
    } else if (type === 't') {
      return new TAxis(params);
    }
  };

  poly.guide.axes = function(params) {
    return new Axes(params);
  };

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Legends (Guide)
---------
Classes related to the generation and management of legends.

Legend object takes in required input and produces abstract geometrical
objects that can be rendered using the Geometry class. Legends are less
disposable compared to axes and layers, because legends themselves may be
added, removed, or modified.

Each legend assumes that it will render at coordinate (0,0). It is up to the
Legends (GuideSet) object to determine the correct position of a legend.
*/


(function() {
  var Legend, Legends, sf,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  sf = poly["const"].scaleFns;

  poly.guide.legends = function() {
    return new Legends();
  };

  poly.guide.legend = function(aes) {
    return new Legend(aes);
  };

  Legends = (function(_super) {

    __extends(Legends, _super);

    function Legends() {
      this.legends = [];
      this.deletedLegends = [];
    }

    Legends.prototype.make = function(params) {
      var aes, aesGroups, domains, guideSpec, i, idx, layerMapping, layers, legend, legenddeleted, mapping, scales, _i, _j, _len, _len1, _ref, _ref1, _results;
      mapping = params.mapping, domains = params.domains, layers = params.layers, guideSpec = params.guideSpec, scales = params.scales, layerMapping = params.layerMapping;
      aesGroups = this._mergeAes(domains, layers);
      idx = 0;
      while (idx < this.legends.length) {
        legend = this.legends[idx];
        legenddeleted = true;
        i = 0;
        while (i < aesGroups.length) {
          aes = aesGroups[i];
          if (_.isEqual(aes, legend.aes)) {
            aesGroups.splice(i, 1);
            legenddeleted = false;
            break;
          }
          i++;
        }
        if (legenddeleted) {
          this.deletedLegends.push(legend);
          this.legends.splice(idx, 1);
        } else {
          idx++;
        }
      }
      for (_i = 0, _len = aesGroups.length; _i < _len; _i++) {
        aes = aesGroups[_i];
        this.legends.push(poly.guide.legend(aes));
      }
      _ref = this.legends;
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        legend = _ref[_j];
        aes = legend.aes[0];
        _results.push(legend.make({
          domain: domains[aes],
          guideSpec: (_ref1 = guideSpec[aes]) != null ? _ref1 : {},
          type: scales[aes].tickType(),
          mapping: layerMapping,
          keys: poly.getLabel(this.layers, aes)
        }));
      }
      return _results;
    };

    Legends.prototype._mergeAes = function(domains, layers) {
      var aes, m, mapped, merged, merging, _i, _len;
      merging = [];
      for (aes in domains) {
        if (__indexOf.call(poly["const"].noLegend, aes) >= 0) {
          continue;
        }
        mapped = _.map(layers, function(layer) {
          return layer.mapping[aes];
        });
        if (!_.all(mapped, _.isUndefined)) {
          merged = false;
          for (_i = 0, _len = merging.length; _i < _len; _i++) {
            m = merging[_i];
            if (_.isEqual(m.mapped, mapped)) {
              m.aes.push(aes);
              merged = true;
              break;
            }
          }
          if (!merged) {
            merging.push({
              aes: [aes],
              mapped: mapped
            });
          }
        }
      }
      return _.pluck(merging, 'aes');
    };

    Legends.prototype.getDimension = function(dims) {
      var d, legend, maxheight, maxwidth, offset, _i, _len, _ref;
      maxheight = dims.height - dims.guideTop - dims.paddingTop;
      maxwidth = 0;
      offset = {
        x: 10,
        y: 0
      };
      _ref = this.legends;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        legend = _ref[_i];
        d = legend.getDimension();
        if (d.height + offset.y > maxheight) {
          offset.x += maxwidth + 5;
          offset.y = 0;
          maxwidth = 0;
        }
        if (d.width > maxwidth) {
          maxwidth = d.width;
        }
        offset.y += d.height;
      }
      return {
        right: offset.x + maxwidth
      };
    };

    Legends.prototype.render = function(dims, renderer, offset) {
      var legend, legendDim, maxheight, maxwidth, newdim, realoffset, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (offset == null) {
        offset = {
          x: 10,
          y: 0
        };
      }
      _ref = this.deletedLegends;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        legend = _ref[_i];
        legend.dispose(renderer());
      }
      this.deletedLegends = [];
      legendDim = {
        top: dims.paddingTop + dims.guideTop,
        right: dims.width - dims.guideRight - dims.paddingRight
      };
      maxwidth = 0;
      maxheight = dims.height - dims.guideTop - dims.paddingTop;
      _ref1 = this.legends;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        legend = _ref1[_j];
        newdim = legend.getDimension();
        if (newdim.height + offset.y > maxheight) {
          offset.x += maxwidth + 5;
          offset.y = 0;
          maxwidth = 0;
        }
        if (newdim.width > maxwidth) {
          maxwidth = newdim.width;
        }
        realoffset = {
          x: offset.x + legendDim.right,
          y: offset.y + legendDim.top
        };
        legend.render(renderer(realoffset, false, false));
        _results.push(offset.y += newdim.height);
      }
      return _results;
    };

    Legends.prototype.dispose = function(renderer) {
      var legend, _i, _len, _ref, _results;
      _ref = this.legends;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        legend = _ref[_i];
        _results.push(legend.dispose(renderer()));
      }
      return _results;
    };

    return Legends;

  })(poly.GuideSet);

  Legend = (function(_super) {

    __extends(Legend, _super);

    function Legend(aes) {
      this.aes = aes;
      this._makeEvtData = __bind(this._makeEvtData, this);

      this._makeTick = __bind(this._makeTick, this);

      this.geometry = new poly.Geometry;
    }

    Legend.prototype.make = function(params) {
      var domain, guideSpec, keys, tickWidth, titleWidth, type, _ref;
      domain = params.domain, type = params.type, guideSpec = params.guideSpec, this.mapping = params.mapping, keys = params.keys;
      this.titletext = (_ref = guideSpec.title) != null ? _ref : keys;
      this.ticks = poly.tick.make(domain, guideSpec, type);
      this.height = this.TITLEHEIGHT + this.SPACING + this.TICKHEIGHT * _.size(this.ticks);
      titleWidth = poly.strSize(this.titletext);
      tickWidth = _.max(_.map(this.ticks, function(t) {
        return poly.strSize(t.value);
      }));
      return this.maxwidth = Math.max(titleWidth, tickWidth);
    };

    Legend.prototype.calculate = function() {
      var evtData, geoms, key, marks, tick, _ref;
      geoms = {};
      geoms['title'] = {
        marks: {
          0: this._makeTitle(this.titletext)
        }
      };
      _ref = this.ticks;
      for (key in _ref) {
        tick = _ref[key];
        marks = {};
        marks.tick = this._makeTick(tick);
        marks.text = this._makeLabel(tick);
        evtData = this._makeEvtData(tick);
        geoms[key] = {
          marks: marks,
          evtData: evtData
        };
      }
      return geoms;
    };

    Legend.prototype.render = function(renderer) {
      this.geometry.set(this.calculate());
      return this.geometry.render(renderer);
    };

    Legend.prototype.dispose = function(renderer) {
      return this.geometry.dispose(renderer);
    };

    Legend.prototype._makeLabel = function(tick) {
      return {
        type: 'text',
        x: sf.identity(20),
        y: sf.identity((15 + tick.index * 12) + 1),
        text: tick.value,
        'text-anchor': 'start'
      };
    };

    Legend.prototype._makeTick = function(tick) {
      var aes, obj, value, _ref;
      obj = {
        type: 'circle',
        x: sf.identity(10),
        y: sf.identity(15 + tick.index * 12),
        color: sf.identity('steelblue')
      };
      _ref = this.mapping;
      for (aes in _ref) {
        value = _ref[aes];
        if (__indexOf.call(poly["const"].noLegend, aes) >= 0) {
          continue;
        }
        value = value[0];
        if (__indexOf.call(this.aes, aes) >= 0) {
          obj[aes] = tick.location;
        } else if ((value.type != null) && value.type === 'const') {
          obj[aes] = sf.identity(value.value);
        } else if (!_.isObject(value)) {
          obj[aes] = sf.identity(value);
        } else {
          obj[aes] = sf.identity(poly["const"].defaults[aes]);
        }
      }
      return obj;
    };

    Legend.prototype._makeEvtData = function(tick) {
      var aes, evtData, v, value, _i, _len, _ref;
      evtData = {};
      _ref = this.mapping;
      for (aes in _ref) {
        value = _ref[aes];
        if (__indexOf.call(poly["const"].noLegend, aes) >= 0) {
          continue;
        }
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          v = value[_i];
          if (__indexOf.call(this.aes, aes) >= 0 && v.type === 'map') {
            evtData[v.value] = tick.evtData;
          }
        }
      }
      return evtData;
    };

    Legend.prototype._makeTitle = function(text) {
      return {
        type: 'text',
        x: sf.identity(5),
        y: sf.identity(0),
        text: text,
        'text-anchor': 'start'
      };
    };

    Legend.prototype.getDimension = function() {
      return {
        position: 'left',
        height: this.height,
        width: 15 + this.maxwidth
      };
    };

    return Legend;

  })(poly.Guide);

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
# CONSTANTS
*/


(function() {
  var Area, Brewer, Color, Gradient, Gradient2, Identity, Linear, Log, Opacity, PositionScale, Scale, Shape, aesthetics,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  aesthetics = poly["const"].aes;

  /*
  # GLOBALS
  */


  poly.scale = {
    linear: function(params) {
      return new Linear(params);
    },
    log: function(params) {
      return new Log(params);
    },
    area: function(params) {
      return new Area(params);
    },
    color: function(params) {
      return new Color(params);
    },
    gradient: function(params) {
      return new Gradient(params);
    },
    identity: function(params) {
      return new Identity(params);
    },
    opacity: function(params) {
      return new Opacity(params);
    }
  };

  /*
  Scales here are objects that can construct functions that takes a value from
  the data, and returns another value that is suitable for rendering an
  attribute of that value.
  */


  Scale = (function() {

    function Scale(params) {
      this.f = null;
    }

    Scale.prototype.make = function(domain) {
      this.domain = domain;
      this.compare = poly.domain.compare(domain);
      if (!domain) {
        return this._makeNone();
      }
      switch (domain.type) {
        case 'num':
          return this._makeNum();
        case 'date':
          return this._makeDate();
        case 'cat':
          return this._makeCat();
      }
    };

    Scale.prototype._makeNone = function() {
      throw poly.error.impl("You are using a scale that does not support null values");
    };

    Scale.prototype._makeNum = function() {
      throw poly.error.impl("You are using a scale that does not support numbers");
    };

    Scale.prototype._makeDate = function() {
      throw poly.error.impl("You are using a scale that does not support dates");
    };

    Scale.prototype._makeCat = function() {
      throw poly.error.impl("You are using a scale that does not support categories");
    };

    Scale.prototype.tickType = function() {
      if (!this.domain) {
        return this._tickNone();
      }
      switch (this.domain.type) {
        case 'num':
          return this._tickNum();
        case 'date':
          return this._tickDate();
        case 'cat':
          return this._tickCat();
      }
    };

    Scale.prototype._tickNone = function() {
      return 'none';
    };

    Scale.prototype._tickNum = function() {
      return 'num';
    };

    Scale.prototype._tickDate = function() {
      return 'date';
    };

    Scale.prototype._tickCat = function() {
      return 'cat';
    };

    Scale.prototype._identityWrapper = function(y) {
      return function(x) {
        if (_.isObject(x) && x.t === 'scalefn') {
          if (x.f === 'identity') {
            return x.v;
          }
        }
        return y(x);
      };
    };

    return Scale;

  })();

  /*
  Position Scales for the x- and y-axes
  */


  PositionScale = (function(_super) {

    __extends(PositionScale, _super);

    function PositionScale(params) {
      this._catWrapper = __bind(this._catWrapper, this);

      this._dateWrapper = __bind(this._dateWrapper, this);

      this._numWrapper = __bind(this._numWrapper, this);
      this.f = null;
      this.finv = null;
    }

    PositionScale.prototype.make = function(domain, range, space) {
      this.range = range;
      this.space = space;
      if (!_.isNumber(this.space)) {
        this.space = 0.05;
      }
      return PositionScale.__super__.make.call(this, domain);
    };

    PositionScale.prototype._makeNone = function() {
      var space,
        _this = this;
      space = (this.range.max - this.range.min) * this.space;
      this.f = this._NaNCheckWrap(function(value) {
        var width;
        if (_.isObject(value)) {
          if (value.f === 'identity') {
            return value.v;
          }
          if (value.f === 'middle') {
            return _this.range.max / 2 + _this.range.min / 2;
          }
          if (value.f === 'max') {
            return _this.range.max;
          }
          if (value.f === 'min') {
            return _this.range.min;
          }
          if (value.f === 'upper' && !value.m) {
            return _this.range.max - space;
          }
          if (value.f === 'lower' && !value.m) {
            return _this.range.min + space;
          }
          width = (_this.range.max - _this.range.min - 2 * space) / value.m;
          if (value.f === 'upper') {
            return (_this.range.min + space) + (value.n + 1) * width;
          }
          if (value.f === 'lower') {
            return (_this.range.min + space) + value.n * width;
          }
        }
        return _this.range.max / 2 + _this.range.min / 2;
      });
      return this.finv = function() {
        return {};
      };
    };

    PositionScale.prototype._NaNCheckWrap = function(fn) {
      return function(value) {
        var out;
        out = fn(value);
        if (isNaN(out) || out === Infinity || out === -Infinity) {
          throw poly.error.input("SCALE BEHAVING BADLY");
        }
        return out;
      };
    };

    PositionScale.prototype._numWrapper = function(domain, y) {
      var _this = this;
      return this._NaNCheckWrap(function(value) {
        var lower, space, upper, width, _ref;
        if (_.isObject(value)) {
          if (value.t === 'scalefn') {
            if (value.f === 'identity') {
              return value.v;
            }
            if (value.f === 'middle') {
              return y(value.v + domain.bw / 2);
            }
            if (value.f === 'max') {
              return _this.range.max + value.v;
            }
            if (value.f === 'min') {
              return _this.range.min + value.v;
            }
            if ((_ref = value.f) === 'upper' || _ref === 'lower') {
              upper = y(value.v + domain.bw);
              lower = y(value.v);
              space = (upper - lower) * _this.space;
              if (value.f === 'upper' && !value.m) {
                return upper - space;
              }
              if (value.f === 'lower' && !value.m) {
                return lower + space;
              }
              width = (upper - lower - 2 * space) / value.m;
              if (value.f === 'upper') {
                return (lower + space) + (value.n + 1) * width;
              }
              if (value.f === 'lower') {
                return (lower + space) + value.n * width;
              }
            }
          }
          throw poly.error.input("Unknown object " + value + " is passed to a scale");
        }
        return y(value);
      });
    };

    PositionScale.prototype._dateWrapper = function(domain, y) {
      var _this = this;
      return this._NaNCheckWrap(function(value) {
        var lower, m, space, upper, width, _ref;
        if (_.isObject(value)) {
          if (value.t === 'scalefn') {
            if (value.f === 'identity') {
              return value.v;
            }
            if (value.f === 'max') {
              return _this.range.max + value.v;
            }
            if (value.f === 'min') {
              return _this.range.min + value.v;
            }
            if ((_ref = value.f) === 'upper' || _ref === 'middle' || _ref === 'lower') {
              upper = domain.bw === 'week' ? moment.unix(value.v).day(7).unix() : domain.bw === 'decade' ? (m = moment.unix(value.v).startOf('year'), m.year(10 * Math.floor(m.year() / 10)), m.unix()) : moment.unix(value.v).endOf(domain.bw).unix();
              upper = y(upper);
              lower = domain.bw === 'week' ? moment.unix(value.v).day(0).unix() : domain.bw === 'decade' ? (m = moment.unix(value.v).startOf('year'), m.year(10 * Math.floor(m.year() / 10) + 10), m.unix()) : moment.unix(value.v).startOf(domain.bw).unix();
              lower = y(lower);
              space = (upper - lower) * _this.space;
              if (value.f === 'middle') {
                return upper / 2 + lower / 2;
              }
              if (value.f === 'upper' && !value.m) {
                return upper - space;
              }
              if (value.f === 'lower' && !value.m) {
                return lower + space;
              }
              width = (upper - lower - 2 * space) / value.m;
              if (value.f === 'upper') {
                return (lower + space) + (value.n + 1) * width;
              }
              if (value.f === 'lower') {
                return (lower + space) + value.n * width;
              }
            }
          }
          throw poly.error.input("Unknown object " + value + " is passed to a scale");
        }
        return y(value);
      });
    };

    PositionScale.prototype._catWrapper = function(step, y) {
      var _this = this;
      return this._NaNCheckWrap(function(value) {
        var lower, space, upper, width, _ref;
        space = step * _this.space;
        if (_.isObject(value)) {
          if (value.t === 'scalefn') {
            if (value.f === 'identity') {
              return value.v;
            }
            if (value.f === 'max') {
              return _this.range.max + value.v;
            }
            if (value.f === 'min') {
              return _this.range.min + value.v;
            }
            if ((_ref = value.f) === 'upper' || _ref === 'middle' || _ref === 'lower') {
              upper = y(value.v) + step;
              lower = y(value.v);
              if (value.f === 'middle') {
                return upper / 2 + lower / 2;
              }
              if (value.f === 'upper' && !value.m) {
                return upper - space;
              }
              if (value.f === 'lower' && !value.m) {
                return lower + space;
              }
              width = (upper - lower - 2 * space) / value.m;
              if (value.f === 'upper') {
                return (lower + space) + (value.n + 1) * width;
              }
              if (value.f === 'lower') {
                return (lower + space) + value.n * width;
              }
            }
          }
          throw poly.error.input("Unknown object " + value + " is passed to a scale");
        }
        return y(value) + step / 2;
      });
    };

    return PositionScale;

  })(Scale);

  Linear = (function(_super) {

    __extends(Linear, _super);

    function Linear() {
      return Linear.__super__.constructor.apply(this, arguments);
    }

    Linear.prototype._makeNum = function() {
      var x, y;
      y = poly.linear(this.domain.min, this.range.min, this.domain.max, this.range.max);
      x = poly.linear(this.range.min, this.domain.min, this.range.max, this.domain.max);
      this.f = this._numWrapper(this.domain, y);
      return this.finv = function(y1, y2) {
        var xs;
        xs = [x(y1), x(y2)];
        return {
          ge: _.min(xs),
          le: _.max(xs)
        };
      };
    };

    Linear.prototype._makeDate = function() {
      var x, y;
      y = poly.linear(this.domain.min, this.range.min, this.domain.max, this.range.max);
      x = poly.linear(this.range.min, this.domain.min, this.range.max, this.domain.max);
      this.f = this._dateWrapper(this.domain, y);
      return this.finv = function(y1, y2) {
        var xs;
        xs = [x(y1), x(y2)];
        return {
          ge: _.min(xs),
          le: _.max(xs)
        };
      };
    };

    Linear.prototype._makeCat = function() {
      var step, x, y,
        _this = this;
      step = (this.range.max - this.range.min) / this.domain.levels.length;
      y = function(x) {
        var i;
        i = _.indexOf(_this.domain.levels, x);
        if (i === -1) {
          return null;
        } else {
          return _this.range.min + i * step;
        }
      };
      x = function(y1, y2) {
        var i1, i2, tmp;
        if (y2 < y1) {
          tmp = y2;
          y2 = y1;
          y1 = tmp;
        }
        i1 = Math.floor(y1 / step);
        i2 = Math.ceil(y2 / step);
        return {
          "in": _this.domain.levels.slice(i1, +i2 + 1 || 9e9)
        };
      };
      this.f = this._catWrapper(step, y);
      return this.finv = x;
    };

    return Linear;

  })(PositionScale);

  Log = (function(_super) {

    __extends(Log, _super);

    function Log() {
      return Log.__super__.constructor.apply(this, arguments);
    }

    Log.prototype._makeNum = function() {
      var lg, x, ylin, ylininv;
      lg = Math.log;
      ylin = poly.linear(lg(this.domain.min), this.range.min, lg(this.domain.max), this.range.max);
      this.f = this._numWrapper(function(x) {
        return ylin(lg(x));
      });
      ylininv = poly.linear(this.range.min, lg(this.domain.min), this.range.max, lg(this.domain.max));
      x = function(y) {
        return Math.exp(ylininv(y));
      };
      return this.finv = function(y1, y2) {
        var xs;
        xs = [x(y1), x(y2)];
        return {
          ge: _.min(xs),
          le: _.max(xs)
        };
      };
    };

    Log.prototype._tickNum = function() {
      return 'num-log';
    };

    return Log;

  })(PositionScale);

  /*
  Other, legend-type scales for the x- and y-axes
  */


  Area = (function(_super) {

    __extends(Area, _super);

    function Area() {
      this._makeNum = __bind(this._makeNum, this);
      return Area.__super__.constructor.apply(this, arguments);
    }

    Area.prototype._makeNum = function() {
      var min, sq, ylin;
      min = this.domain.min === 0 ? 0 : 1;
      sq = Math.sqrt;
      ylin = poly.linear(sq(this.domain.min), min, sq(this.domain.max), 10);
      return this.f = this._identityWrapper(function(x) {
        return ylin(sq(x));
      });
    };

    return Area;

  })(Scale);

  Opacity = (function(_super) {

    __extends(Opacity, _super);

    function Opacity() {
      this._makeNum = __bind(this._makeNum, this);
      return Opacity.__super__.constructor.apply(this, arguments);
    }

    Opacity.prototype._makeNum = function() {
      var max, min;
      min = this.domain.min === 0 ? 0 : 0.1;
      max = 1;
      return this.f = this._identityWrapper(poly.linear(this.domain.min, min, this.domain.max, max));
    };

    return Opacity;

  })(Scale);

  Color = (function(_super) {

    __extends(Color, _super);

    function Color() {
      this._makeNum = __bind(this._makeNum, this);

      this._makeCat = __bind(this._makeCat, this);
      return Color.__super__.constructor.apply(this, arguments);
    }

    Color.prototype._makeCat = function() {
      var colors, h, n,
        _this = this;
      n = this.domain.levels.length;
      if (n <= 9) {
        colors = ["#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF", "#999999"];
        return this.f = function(value) {
          var i;
          i = _.indexOf(_this.domain.levels, value);
          return colors[i];
        };
      } else {
        h = function(v) {
          return _.indexOf(_this.domain.levels, v) / n + 1 / (2 * n);
        };
        return this.f = function(value) {
          return Raphael.hsl(h(value), 0.5, 0.5);
        };
      }
    };

    Color.prototype._makeNum = function() {
      var h;
      h = poly.linear(this.domain.min, 0, this.domain.max, 1);
      return this.f = function(value) {
        return Raphael.hsl(0.5, h(value), 0.5);
      };
    };

    return Color;

  })(Scale);

  Brewer = (function(_super) {

    __extends(Brewer, _super);

    function Brewer() {
      return Brewer.__super__.constructor.apply(this, arguments);
    }

    Brewer.prototype._makeCat = function() {};

    return Brewer;

  })(Scale);

  Gradient = (function(_super) {

    __extends(Gradient, _super);

    function Gradient(params) {
      this._makeNum = __bind(this._makeNum, this);
      this.lower = params.lower, this.upper = params.upper;
    }

    Gradient.prototype._makeNum = function() {
      var b, g, lower, r, upper,
        _this = this;
      lower = Raphael.color(this.lower);
      upper = Raphael.color(this.upper);
      r = poly.linear(this.domain.min, lower.r, this.domain.max, upper.r);
      g = poly.linear(this.domain.min, lower.g, this.domain.max, upper.g);
      b = poly.linear(this.domain.min, lower.b, this.domain.max, upper.b);
      return this.f = this._identityWrapper(function(value) {
        return Raphael.rgb(r(value), g(value), b(value));
      });
    };

    return Gradient;

  })(Scale);

  Gradient2 = (function(_super) {

    __extends(Gradient2, _super);

    function Gradient2(params) {
      this._makeCat = __bind(this._makeCat, this);

      var lower, upper, zero;
      lower = params.lower, zero = params.zero, upper = params.upper;
    }

    Gradient2.prototype._makeCat = function() {};

    return Gradient2;

  })(Scale);

  Shape = (function(_super) {

    __extends(Shape, _super);

    function Shape() {
      return Shape.__super__.constructor.apply(this, arguments);
    }

    Shape.prototype._makeCat = function() {};

    return Shape;

  })(Scale);

  Identity = (function(_super) {

    __extends(Identity, _super);

    function Identity() {
      return Identity.__super__.constructor.apply(this, arguments);
    }

    Identity.prototype.make = function() {
      this.compare = function(a, b) {
        return 0;
      };
      return this.f = this._identityWrapper(function(x) {
        return x;
      });
    };

    return Identity;

  })(Scale);

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var ScaleSet;

  poly.scaleset = function(guideSpec, domains, ranges) {
    return new ScaleSet(guideSpec, domains, ranges);
  };

  ScaleSet = (function() {

    function ScaleSet(tmpRanges, coord) {
      this.coord = coord;
      this.ranges = tmpRanges;
      this.axes = poly.guide.axes();
      this.legends = poly.guide.legends();
    }

    ScaleSet.prototype.make = function(guideSpec, domains, layers) {
      this.guideSpec = guideSpec;
      this.layers = layers;
      this.domains = domains;
      this.domainx = this.domains.x;
      this.domainy = this.domains.y;
      this.scales = this._makeScales(guideSpec, domains, this.ranges);
      this.reverse = {
        x: this.scales.x.finv,
        y: this.scales.y.finv
      };
      return this.layerMapping = this._mapLayers(layers);
    };

    ScaleSet.prototype.setRanges = function(ranges) {
      this.ranges = ranges;
      this._makeXScale();
      return this._makeYScale();
    };

    ScaleSet.prototype.setXDomain = function(d) {
      this.domainx = d;
      return this._makeXScale();
    };

    ScaleSet.prototype.setYDomain = function(d) {
      this.domainy = d;
      return this._makeYScale();
    };

    ScaleSet.prototype.resetDomains = function() {
      this.domainx = this.domains.x;
      this.domainy = this.domains.y;
      this._makeXScale();
      return this._makeYScale();
    };

    ScaleSet.prototype._makeXScale = function() {
      return this.scales.x.make(this.domainx, this.ranges.x, this.getSpec('x').padding);
    };

    ScaleSet.prototype._makeYScale = function() {
      return this.scales.y.make(this.domainy, this.ranges.y, this.getSpec('y').padding);
    };

    ScaleSet.prototype._makeScales = function(guideSpec, domains, ranges) {
      var scales, specScale, _ref, _ref1, _ref2, _ref3;
      specScale = function(a) {
        if (guideSpec && (guideSpec[a] != null) && (guideSpec[a].scale != null)) {
          return guideSpec[a].scale;
        }
        return null;
      };
      scales = {};
      scales.x = (_ref = specScale('x')) != null ? _ref : poly.scale.linear();
      scales.x.make(domains.x, ranges.x, this.getSpec('x').padding);
      scales.y = (_ref1 = specScale('y')) != null ? _ref1 : poly.scale.linear();
      scales.y.make(domains.y, ranges.y, this.getSpec('y').padding);
      if (domains.color != null) {
        if (domains.color.type === 'cat') {
          scales.color = (_ref2 = specScale('color')) != null ? _ref2 : poly.scale.color();
        } else {
          scales.color = (_ref3 = specScale('color')) != null ? _ref3 : poly.scale.gradient({
            upper: 'steelblue',
            lower: 'red'
          });
        }
        scales.color.make(domains.color);
      }
      if (domains.size != null) {
        scales.size = specScale('size') || poly.scale.area();
        scales.size.make(domains.size);
      }
      if (domains.opacity != null) {
        scales.opacity = specScale('opacity') || poly.scale.opacity();
        scales.opacity.make(domains.opacity);
      }
      scales.text = poly.scale.identity();
      scales.text.make();
      return scales;
    };

    ScaleSet.prototype.fromPixels = function(start, end) {
      var map, obj, x, y, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      _ref = this.coord.getAes(start, end, this.reverse), x = _ref.x, y = _ref.y;
      obj = {};
      _ref1 = this.layerMapping.x;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        map = _ref1[_i];
        if ((map.type != null) && map.type === 'map') {
          obj[map.value] = x;
        }
      }
      _ref2 = this.layerMapping.y;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        map = _ref2[_j];
        if ((map.type != null) && map.type === 'map') {
          obj[map.value] = y;
        }
      }
      return obj;
    };

    ScaleSet.prototype.getSpec = function(a) {
      if ((this.guideSpec != null) && (this.guideSpec[a] != null)) {
        return this.guideSpec[a];
      } else {
        return {};
      }
    };

    ScaleSet.prototype.makeTitles = function(maintitle) {
      var _ref;
      if ((_ref = this.titles) == null) {
        this.titles = {
          x: poly.guide.title(this.coord.axisType('x')),
          y: poly.guide.title(this.coord.axisType('y')),
          main: poly.guide.title('main')
        };
      }
      this.titles.main.make({
        title: maintitle,
        guideSpec: {},
        position: "top"
      });
      this.titles.x.make({
        guideSpec: this.getSpec('x'),
        title: poly.getLabel(this.layers, 'x')
      });
      return this.titles.y.make({
        guideSpec: this.getSpec('y'),
        title: poly.getLabel(this.layers, 'y')
      });
    };

    ScaleSet.prototype.titleOffset = function(dim) {
      var dir, key, o, offset, title, _i, _len, _ref, _ref1, _ref2;
      offset = {};
      _ref = this.titles;
      for (key in _ref) {
        title = _ref[key];
        o = title.getDimension();
        _ref1 = ['left', 'right', 'top', ' bottom'];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          dir = _ref1[_i];
          if (o[dir]) {
            if ((_ref2 = offset[dir]) == null) {
              offset[dir] = 0;
            }
            offset[dir] += o[dir];
          }
        }
      }
      return offset;
    };

    ScaleSet.prototype.renderTitles = function(dims, renderer) {
      var o;
      renderer = renderer({}, false, false);
      o = this.axesOffset(dims);
      this.titles.x.render(renderer, dims, o);
      this.titles.y.render(renderer, dims, o);
      return this.titles.main.render(renderer, dims, o);
    };

    ScaleSet.prototype.disposeTitles = function(renderer) {
      this.titles = {};
      this.titles.x.dispose(renderer);
      this.titles.y.dispose(renderer);
      return this.titles.main.dispose(renderer);
    };

    ScaleSet.prototype.makeAxes = function() {
      var _ref;
      return this.axes.make({
        domains: {
          x: this.domainx,
          y: this.domainy
        },
        coord: this.coord,
        scales: this.scales,
        specs: (_ref = this.guideSpec) != null ? _ref : {},
        labels: {
          x: poly.getLabel(this.layers, 'x'),
          y: poly.getLabel(this.layers, 'y')
        }
      });
    };

    ScaleSet.prototype.axesOffset = function(dims) {
      return this.axes.getDimension(dims);
    };

    ScaleSet.prototype.renderAxes = function(dims, renderer, facet) {
      return this.axes.render(dims, renderer, facet);
    };

    ScaleSet.prototype.disposeAxes = function(renderer) {
      return this.axes.dispose(renderer);
    };

    ScaleSet.prototype._mapLayers = function(layers) {
      var aes, obj, _i, _len, _ref;
      obj = {};
      _ref = poly["const"].aes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        aes = _ref[_i];
        obj[aes] = _.map(layers, function(layer) {
          if (layer.mapping[aes] != null) {
            return {
              type: 'map',
              value: layer.mapping[aes]
            };
          } else if (layer.consts[aes] != null) {
            return {
              type: 'const',
              value: layer.consts[aes]
            };
          } else {
            return layer.defaults[aes];
          }
        });
      }
      return obj;
    };

    ScaleSet.prototype.makeLegends = function(mapping) {
      return this.legends.make({
        mapping: mapping,
        domains: this.domains,
        layers: this.layers,
        guideSpec: this.guideSpec,
        scales: this.scales,
        layerMapping: this.layerMapping
      });
    };

    ScaleSet.prototype.legendOffset = function(dims) {
      return this.legends.getDimension(dims);
    };

    ScaleSet.prototype.renderLegends = function(dims, renderer) {
      var offset, _ref, _ref1;
      offset = {
        x: 10,
        y: 0
      };
      offset.x += (_ref = this.axesOffset(dims).right) != null ? _ref : 0;
      offset.x += (_ref1 = this.titleOffset(dims).right) != null ? _ref1 : 0;
      return this.legends.render(dims, renderer, offset);
    };

    ScaleSet.prototype.disposeLegends = function(renderer) {
      return this.legends.dispose(renderer);
    };

    return ScaleSet;

  })();

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Data Object
---------
Polychart wrapper around a data set. This is contains the data structure
required for poly.chart().  Data object that either contains JSON format
of a dataset, or knows how to retrieve data from some source.
*/


(function() {
  var AbstractData, BackendData, FrontendData, _getArray, _getCSV, _getObject,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  poly.data = function(params) {
    if (params.url) {
      return new BackendData(params);
    } else {
      return new FrontendData(params);
    }
  };

  /*
  Helper functions
  */


  _getArray = function(json, meta) {
    var first100, item, key, keys, raw, _i, _j, _k, _len, _len1, _len2, _ref;
    if (json.length > 0) {
      keys = _.union(_.keys(meta), _.keys(json[0]));
      first100 = json.slice(0, 100);
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        if ((_ref = meta[key]) == null) {
          meta[key] = {};
        }
        if (!meta[key].type) {
          meta[key].type = poly.type.impute(_.pluck(first100, key));
        }
      }
      for (_j = 0, _len1 = json.length; _j < _len1; _j++) {
        item = json[_j];
        for (_k = 0, _len2 = keys.length; _k < _len2; _k++) {
          key = keys[_k];
          if (_.isString(item[key])) {
            item[key] = poly.type.coerce(item[key], meta[key]);
          }
        }
      }
      key = keys;
      raw = json;
    } else {
      key = _.keys(meta);
      raw = [];
    }
    return {
      key: key,
      raw: raw,
      meta: meta
    };
  };

  _getObject = function(json, meta) {
    var i, k, key, keys, len, obj, raw, _i, _j, _k, _len, _len1, _ref, _ref1;
    keys = _.keys(json);
    raw = [];
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      if ((_ref = meta[key]) == null) {
        meta[key] = {};
      }
      if (!meta[key].type) {
        meta[key].type = poly.type.impute(json[key].slice(0, 100));
      }
    }
    if (keys.length > 0) {
      len = json[keys[0]].length;
      if (len > 0) {
        for (i = _j = 0, _ref1 = len - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          obj = {};
          for (_k = 0, _len1 = keys.length; _k < _len1; _k++) {
            k = keys[_k];
            obj[k] = poly.type.coerce(json[k][i], meta[k]);
          }
          raw.push(obj);
        }
      }
    }
    key = keys;
    return {
      key: key,
      raw: raw,
      meta: meta
    };
  };

  _getCSV = function(str, meta) {
    return _getObject(poly.csv.parse(str));
  };

  /*
  Classes
  */


  AbstractData = (function() {

    AbstractData.prototype.isData = true;

    function AbstractData() {
      this.raw = {};
      this.meta = {};
      this.key = [];
      this.subscribed = [];
    }

    AbstractData.prototype.update = function() {
      var fn, _i, _len, _ref, _results;
      _ref = this.subscribed;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        _results.push(fn());
      }
      return _results;
    };

    AbstractData.prototype.subscribe = function(h) {
      if (_.indexOf(this.subscribed, h) === -1) {
        return this.subscribed.push(h);
      }
    };

    AbstractData.prototype.unsubscribe = function(h) {
      return this.subscribed.splice(_.indexOf(this.subscribed, h), 1);
    };

    AbstractData.prototype.keys = function() {
      return this.key;
    };

    return AbstractData;

  })();

  FrontendData = (function(_super) {

    __extends(FrontendData, _super);

    function FrontendData(params) {
      FrontendData.__super__.constructor.call(this);
      this._setData(params);
    }

    FrontendData.prototype.getData = function(callback) {
      return callback(this);
    };

    FrontendData.prototype.update = function(params) {
      this._setData(params);
      return FrontendData.__super__.update.call(this);
    };

    FrontendData.prototype._setData = function(params) {
      var csv, json, meta, _ref;
      csv = params.csv, json = params.json, meta = params.meta;
      if (meta == null) {
        meta = {};
      }
      return _ref = csv ? _getCSV(csv, meta) : _.isArray(json) ? _getArray(json, meta) : _.isObject(json) ? _getObject(json, meta) : void 0, this.key = _ref.key, this.raw = _ref.raw, this.meta = _ref.meta, _ref;
    };

    FrontendData.prototype.checkRename = function(from, to) {
      if (to === '') {
        throw poly.error.defn("Column names cannot be an empty string");
      }
      if (_.indexOf(this.key, from) === -1) {
        throw poly.error.defn("The key " + from + " doesn't exist!");
      }
      if (_.indexOf(this.key, to) !== -1) {
        throw poly.error.defn("The key " + to + " already exists!");
      }
    };

    FrontendData.prototype.rename = function(from, to, checked) {
      var item, k, _i, _len, _ref;
      if (checked == null) {
        checked = false;
      }
      from = from.toString();
      to = to.toString();
      if (from === to) {
        return true;
      }
      if (!checked) {
        this.checkRename(from, to);
      }
      _ref = this.raw;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item[to] = item[from];
        delete item[from];
      }
      k = _.indexOf(this.key, from);
      this.key[k] = to;
      this.meta[to] = this.meta[from];
      delete this.meta[from];
      return true;
    };

    FrontendData.prototype.renameMany = function(map) {
      var from, to;
      for (from in map) {
        to = map[from];
        if (from !== to) {
          this.checkRename(from, to);
        }
      }
      for (from in map) {
        to = map[from];
        if (from !== to) {
          this.rename(from, to, true);
        }
      }
      return true;
    };

    FrontendData.prototype.remove = function(key) {
      var index, item, _i, _len, _ref;
      index = _.indexOf(this.key, key);
      if (index === '-1') {
        return false;
      }
      this.key.splice(index, 1);
      delete this.meta[key];
      _ref = this.raw;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        delete item[key];
      }
      return true;
    };

    FrontendData.prototype.filter = function(strfn) {
      var fn, item, newdata, newobj, _i, _len, _ref;
      fn = _.isFunction(strfn) ? strfn : _.isString(strfn) ? new Function('d', "with(d) { return " + strfn + ";}") : function() {
        return true;
      };
      newdata = [];
      _ref = this.raw;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (fn(item)) {
          newdata.push(item);
        }
      }
      newobj = poly.data({
        json: newdata,
        meta: this.meta
      });
      return newobj;
    };

    FrontendData.prototype.sort = function(key, desc) {
      var newdata, newobj, sortfn, type;
      type = this.type(key);
      newdata = _.clone(this.raw);
      sortfn = poly.type.compare(type);
      newdata.sort(function(a, b) {
        return sortfn(a[key], b[key]);
      });
      if (desc) {
        newdata.reverse();
      }
      newobj = poly.data({
        json: newdata,
        meta: this.meta
      });
      return newobj;
    };

    FrontendData.prototype.derive = function(fnstr, key, opts) {
      var compute, context, dryrun, hasFnStr, item, value, _i, _len, _ref;
      if (opts == null) {
        opts = {};
      }
      dryrun = opts.dryrun, context = opts.context;
      if (!(key != null)) {
        key = _uniqueId("var_");
      }
      if (context == null) {
        context = {};
      }
      if (_.isFunction(fnstr)) {
        compute = fnstr;
        hasFnStr = false;
      } else {
        hasFnStr = true;
        compute = new Function('d', "with(this) { with(d) { return " + (fnstr('' ? "" : fnstr)) + ";}}");
      }
      _ref = this.raw;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        value = compute.call(context, item);
        if (_.isFunction(value)) {
          throw poly.error.defn("Derivation function returned another function.");
        }
        item[key] = value;
      }
      if (dryrun) {
        return {
          success: true,
          values: _.pluck(this.raw.slice(0, 11), key)
        };
      }
      if (!(__indexOf.call(this.key, key) >= 0)) {
        this.key.push(key);
      }
      this.meta[key] = {
        type: poly.type.impute(_.pluck(this.raw.slice(0, 101), key)),
        derived: true
      };
      if (hasFnStr) {
        this.meta[key].formula = fnstr;
      }
      return key;
    };

    FrontendData.prototype.getMeta = function(key) {
      return this.meta[key];
    };

    FrontendData.prototype.type = function(key) {
      var t;
      if (key in this.meta) {
        t = this.meta[key].type;
        if (t === 'num') {
          return 'number';
        } else {
          return t;
        }
      }
      throw poly.error.defn("Data does not have column " + key + ".");
    };

    FrontendData.prototype.get = function(key) {
      return _.pluck(this.raw, key);
    };

    FrontendData.prototype.len = function() {
      return this.raw.length;
    };

    FrontendData.prototype.getObject = function(i) {
      return this.raw[i];
    };

    FrontendData.prototype.max = function(key) {
      return _.max(this.get(key));
    };

    FrontendData.prototype.min = function(key) {
      return _.min(this.get(key));
    };

    return FrontendData;

  })(AbstractData);

  BackendData = (function(_super) {

    __extends(BackendData, _super);

    function BackendData(params) {
      BackendData.__super__.constructor.call(this);
      this.url = params.url;
    }

    BackendData.prototype.getData = function(callback) {
      if (this.raw != null) {
        return callback(this);
      }
      return poly.csv(this.url, function(csv) {
        var _ref;
        _ref = _getCSV(csv), this.key = _ref.key, this.raw = _ref.raw, this.meta = _ref.meta;
        return callback(this);
      });
    };

    BackendData.prototype.update = function(params) {
      this.raw = null;
      return BackendData.__super__.update.call(this);
    };

    return BackendData;

  })(AbstractData);

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Wrapper around the data processing piece that keeps track of the kind of
data processing to be done.
*/


(function() {
  var DataProcess, backendProcess, calculateMeta, calculateStats, filterFactory, filters, frontendProcess, statistics, statsFactory, transformFactory, transforms,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  DataProcess = (function() {

    function DataProcess(layerSpec, grouping, strictmode) {
      this._wrap = __bind(this._wrap, this);
      this.dataObj = layerSpec.data;
      this.initialSpec = poly.parser.layerToData(layerSpec, grouping);
      this.prevSpec = null;
      this.strictmode = strictmode;
      this.statData = null;
      this.metaData = {};
    }

    DataProcess.prototype.reset = function(callback) {
      return this.make(this.initialSpec, callback);
    };

    DataProcess.prototype.make = function(spec, grouping, callback) {
      var dataSpec, wrappedCallback;
      dataSpec = poly.parser.layerToData(spec, grouping);
      wrappedCallback = this._wrap(callback);
      if (this.strictmode) {
        wrappedCallback(this.dataObj.json, {});
      }
      if (this.dataObj.computeBackend) {
        return backendProcess(dataSpec, this.dataObj, wrappedCallback);
      } else {
        return this.dataObj.getData(function(data) {
          return frontendProcess(dataSpec, data, wrappedCallback);
        });
      }
    };

    DataProcess.prototype._wrap = function(callback) {
      var _this = this;
      return function(data, metaData) {
        _this.statData = data;
        _this.metaData = metaData;
        return callback(_this.statData, _this.metaData);
      };
    };

    return DataProcess;

  })();

  poly.DataProcess = DataProcess;

  /*
  Temporary
  */


  poly.data.process = function(dataObj, layerSpec, strictmode, callback) {
    var d;
    d = new DataProcess(layerSpec, strictmode);
    d.process(callback);
    return d;
  };

  /*
  TRANSFORMS
  ----------
  Key:value pair of available transformations to a function that creates that
  transformation. Also, a metadata description of the transformation is returned
  when appropriate. (e.g for binning)
  */


  transforms = {
    'bin': function(key, transSpec, meta) {
      var binFn, binwidth, name;
      name = transSpec.name, binwidth = transSpec.binwidth;
      if (meta.type === 'num') {
        if (isNaN(binwidth)) {
          throw poly.error.defn("The binwidth " + binwidth + " is invalid for a numeric varliable");
        }
        binwidth = +binwidth;
        binFn = function(item) {
          return item[name] = binwidth * Math.floor(item[key] / binwidth);
        };
        return {
          trans: binFn,
          meta: {
            bw: binwidth,
            binned: true,
            type: 'num'
          }
        };
      }
      if (meta.type === 'date') {
        if (!(__indexOf.call(poly["const"].timerange, binwidth) >= 0)) {
          throw poly.error.defn("The binwidth " + binwidth + " is invalid for a datetime varliable");
        }
        binFn = function(item) {
          var m;
          if (binwidth === 'week') {
            return item[name] = moment.unix(item[key]).day(0).unix();
          } else if (binwidth === 'decade') {
            m = moment.unix(item[key]).startOf('year');
            m.year(10 * Math.floor(m.year() / 10));
            return item[name] = m.unix();
          } else {
            return item[name] = moment.unix(item[key]).startOf(binwidth).unix();
          }
        };
        return {
          trans: binFn,
          meta: {
            bw: binwidth,
            binned: true,
            type: 'date'
          }
        };
      }
    },
    'lag': function(key, transSpec, meta) {
      var i, lag, lagFn, lastn, name;
      name = transSpec.name, lag = transSpec.lag;
      lastn = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= lag ? _i <= lag : _i >= lag; i = 1 <= lag ? ++_i : --_i) {
          _results.push(void 0);
        }
        return _results;
      })();
      lagFn = function(item) {
        lastn.push(item[key]);
        return item[name] = lastn.shift();
      };
      return {
        trans: lagFn,
        meta: {
          type: meta.type
        }
      };
    }
  };

  /*
  Helper function to figures out which transformation to create, then creates it
  */


  transformFactory = function(key, transSpec, meta) {
    return transforms[transSpec.trans](key, transSpec, meta != null ? meta : {});
  };

  /*
  FILTERS
  ----------
  Key:value pair of available filtering operations to filtering function. The
  filtering function returns true iff the data item satisfies the filtering
  criteria.
  */


  filters = {
    'lt': function(x, value) {
      return x < value;
    },
    'le': function(x, value) {
      return x <= value;
    },
    'gt': function(x, value) {
      return x > value;
    },
    'ge': function(x, value) {
      return x >= value;
    },
    'in': function(x, value) {
      return __indexOf.call(value, x) >= 0;
    }
  };

  /*
  Helper function to figures out which filter to create, then creates it
  */


  filterFactory = function(filterSpec) {
    var filterFuncs;
    filterFuncs = [];
    _.each(filterSpec, function(spec, key) {
      return _.each(spec, function(value, predicate) {
        var filter;
        filter = function(item) {
          return filters[predicate](item[key], value);
        };
        return filterFuncs.push(filter);
      });
    });
    return function(item) {
      var f, _i, _len;
      for (_i = 0, _len = filterFuncs.length; _i < _len; _i++) {
        f = filterFuncs[_i];
        if (!f(item)) {
          return false;
        }
      }
      return true;
    };
  };

  /*
  STATISTICS
  ----------
  Key:value pair of available statistics operations to a function that creates
  the appropriate statistical function given the spec. Each statistics function
  produces one atomic value for each group of data.
  */


  statistics = {
    sum: function(spec) {
      return function(values) {
        return _.reduce(_.without(values, void 0, null), (function(v, m) {
          return v + m;
        }), 0);
      };
    },
    count: function(spec) {
      return function(values) {
        return _.without(values, void 0, null).length;
      };
    },
    uniq: function(spec) {
      return function(values) {
        return (_.uniq(_.without(values, void 0, null))).length;
      };
    },
    min: function(spec) {
      return function(values) {
        return _.min(values);
      };
    },
    max: function(spec) {
      return function(values) {
        return _.max(values);
      };
    },
    median: function(spec) {
      return function(values) {
        return poly.median(values);
      };
    },
    box: function(spec) {
      return function(values) {
        var iqr, len, lowerBound, mid, q2, q4, quarter, sortedValues, splitValues, upperBound, _ref;
        len = values.length;
        if (len > 5) {
          mid = len / 2;
          sortedValues = _.sortBy(values, function(x) {
            return x;
          });
          quarter = Math.ceil(mid) / 2;
          if (quarter % 1 !== 0) {
            quarter = Math.floor(quarter);
            q2 = sortedValues[quarter];
            q4 = sortedValues[(len - 1) - quarter];
          } else {
            q2 = (sortedValues[quarter] + sortedValues[quarter - 1]) / 2;
            q4 = (sortedValues[len - quarter] + sortedValues[(len - quarter) - 1]) / 2;
          }
          iqr = q4 - q2;
          lowerBound = q2 - (1.5 * iqr);
          upperBound = q4 + (1.5 * iqr);
          splitValues = _.groupBy(sortedValues, function(v) {
            return v >= lowerBound && v <= upperBound;
          });
          return {
            q1: _.min(splitValues["true"]),
            q2: q2,
            q3: poly.median(sortedValues, true),
            q4: q4,
            q5: _.max(splitValues["true"]),
            outliers: (_ref = splitValues["false"]) != null ? _ref : []
          };
        }
        return {
          outliers: values
        };
      };
    }
  };

  /*
  Helper function to figures out which statistics to create, then creates it
  */


  statsFactory = function(statSpec) {
    return statistics[statSpec.stat](statSpec);
  };

  /*
  Calculate statistics
  */


  calculateStats = function(data, statSpecs) {
    var groupedData, statFuncs;
    statFuncs = {};
    _.each(statSpecs.stats, function(statSpec) {
      var key, name, statFn;
      key = statSpec.key, name = statSpec.name;
      statFn = statsFactory(statSpec);
      return statFuncs[name] = function(data) {
        return statFn(_.pluck(data, key));
      };
    });
    groupedData = poly.groupBy(data, statSpecs.groups);
    return _.map(groupedData, function(data) {
      var rep;
      rep = {};
      _.each(statSpecs.groups, function(g) {
        return rep[g] = data[0][g];
      });
      _.each(statFuncs, function(stats, name) {
        return rep[name] = stats(data);
      });
      return rep;
    });
  };

  /*
  META
  ----
  Calculations of meta properties including sorting and limiting based on the
  values of statistical calculations
  */


  calculateMeta = function(key, metaSpec, data) {
    var asc, comparator, limit, multiplier, sort, stat, statSpec, values;
    sort = metaSpec.sort, stat = metaSpec.stat, limit = metaSpec.limit, asc = metaSpec.asc;
    if (stat) {
      statSpec = {
        stats: [stat],
        groups: [key]
      };
      data = calculateStats(data, statSpec);
    }
    multiplier = asc ? 1 : -1;
    comparator = function(a, b) {
      if (a[sort] === b[sort]) {
        return 0;
      }
      if (a[sort] >= b[sort]) {
        return 1 * multiplier;
      }
      return -1 * multiplier;
    };
    data.sort(comparator);
    if (limit) {
      data = data.slice(0, +(limit - 1) + 1 || 9e9);
    }
    values = _.uniq(_.pluck(data, key));
    return {
      meta: {
        levels: values,
        sorted: true
      },
      filter: {
        "in": values
      }
    };
  };

  /*
  GENERAL PROCESSING
  ------------------
  Coordinating the actual work being done
  */


  /*
  Perform the necessary computation in the front end
  */


  frontendProcess = function(dataSpec, data, callback) {
    var addMeta, additionalFilter, d, filter, key, meta, metaData, metaSpec, name, statSpec, trans, transSpec, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    metaData = _.clone(data.meta);
    data = _.clone(data.raw);
    if (metaData == null) {
      metaData = {};
    }
    addMeta = function(key, meta) {
      var _ref;
      return metaData[key] = _.extend((_ref = metaData[key]) != null ? _ref : {}, meta);
    };
    if (dataSpec.trans) {
      _ref = dataSpec.trans;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transSpec = _ref[_i];
        key = transSpec.key;
        _ref1 = transformFactory(key, transSpec, metaData[key]), trans = _ref1.trans, meta = _ref1.meta;
        for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
          d = data[_j];
          trans(d);
        }
        addMeta(transSpec.name, meta);
      }
    }
    if (dataSpec.filter) {
      data = _.filter(data, filterFactory(dataSpec.filter));
    }
    if (dataSpec.meta) {
      additionalFilter = {};
      _ref2 = dataSpec.meta;
      for (key in _ref2) {
        metaSpec = _ref2[key];
        _ref3 = calculateMeta(key, metaSpec, data), meta = _ref3.meta, filter = _ref3.filter;
        additionalFilter[key] = filter;
        addMeta(key, meta);
      }
      data = _.filter(data, filterFactory(additionalFilter));
    }
    if (dataSpec.stats && dataSpec.stats.stats && dataSpec.stats.stats.length > 0) {
      data = calculateStats(data, dataSpec.stats);
      _ref4 = dataSpec.stats.stats;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        statSpec = _ref4[_k];
        name = statSpec.name;
        addMeta(name, {
          type: 'num'
        });
      }
    }
    _ref6 = (_ref5 = dataSpec.select) != null ? _ref5 : [];
    for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
      key = _ref6[_l];
      if (!(metaData[key] != null)) {
        throw poly.error.defn("You referenced a data column " + key + " that doesn't exist.");
      }
    }
    return callback(data, metaData);
  };

  /*
  Perform the necessary computation in the backend
  */


  backendProcess = function(dataSpec, rawData, callback) {
    return console.log('backendProcess');
  };

  /*
  For debug purposes only
  */


  poly.data.frontendProcess = frontendProcess;

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
Layer
------------------------------------------
A "Layer" is a visual representation of some data. It is sometimes referred
to as a glymph, geometry, or mark, and was (erronously) referred to as "chart
type" in Polychart graph builder.

Each layer needs to be initiated with a specification object. Once initiated,
the layer's @calculate() function takes a dataset + metadata, and produces
one or more objects representing geometric objects. These geometrical objects
have the appropriate data mapped to each appropriate aesthetics, but the scale
has not yet been applied.

These geometrical objects are be rendered on the screen using the Geometry class
found in abstract.coffee

Layers can be reused: i.e. created once and applied to many versions of the same
data set. It is also disposable, and does not contain state information -- only
state that needs to be preserved for consistency is the geometry.
*/


/*
Shared constants
*/


(function() {
  var Area, Bar, Box, Layer, Line, Path, Point, Text, Tile, aesthetics, defaults, sf,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  aesthetics = poly["const"].aes;

  sf = poly["const"].scaleFns;

  defaults = {
    'x': sf.novalue(),
    'y': sf.novalue(),
    'color': 'steelblue',
    'size': 5,
    'opacity': 0.9,
    'shape': 1
  };

  /*
  Base class for all layers
  */


  Layer = (function() {

    Layer.prototype.defaults = defaults;

    function Layer(spec) {
      var aes, _i, _len;
      this.spec = spec;
      this.mapping = {};
      this.consts = {};
      for (_i = 0, _len = aesthetics.length; _i < _len; _i++) {
        aes = aesthetics[_i];
        if (spec[aes]) {
          if (spec[aes]["var"]) {
            this.mapping[aes] = spec[aes]["var"];
          }
          if (spec[aes]["const"]) {
            this.consts[aes] = spec[aes]["const"];
          }
        }
      }
    }

    Layer.prototype.calculate = function(statData, meta) {
      var aes, key, _ref;
      this.statData = statData;
      this.meta = meta;
      this._calcGeoms();
      this.geoms = (function() {
        if (this.spec.sample === false) {
          return this.geoms;
        } else if (_.isNumber(this.spec.sample)) {
          return poly.sample(this.geoms, this.spec.sample);
        } else {
          throw poly.error.defn("A layer's 'sample' definition should be an integer, not " + this.spec.sample);
        }
      }).call(this);
      meta = {};
      _ref = this.mapping;
      for (aes in _ref) {
        key = _ref[aes];
        meta[aes] = this.meta[key];
      }
      return {
        geoms: this.geoms,
        meta: meta
      };
    };

    Layer.prototype._calcGeoms = function() {
      throw poly.error.impl();
    };

    Layer.prototype._tooltip = function(item) {
      return 'foo';
    };

    Layer.prototype._mappings = function(spec) {};

    Layer.prototype._getValue = function(item, aes) {
      if (this.mapping[aes]) {
        return item[this.mapping[aes]];
      } else if (this.consts[aes]) {
        return sf.identity(this.consts[aes]);
      } else if (aes === 'x' || aes === 'y') {
        return defaults[aes];
      } else {
        return sf.identity(defaults[aes]);
      }
    };

    Layer.prototype._getIdFunc = function() {
      var _this = this;
      if (this.mapping['id'] != null) {
        return function(item) {
          return _this._getValue(item, 'id');
        };
      } else {
        return poly.counter();
      }
    };

    Layer.prototype._fillZeros = function(data, all_x) {
      var data_x, item, missing, x;
      data_x = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          _results.push(this._getValue(item, 'x'));
        }
        return _results;
      }).call(this);
      missing = _.difference(all_x, data_x);
      return {
        x: data_x.concat(missing),
        y: ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            item = data[_i];
            _results.push(this._getValue(item, 'y'));
          }
          return _results;
        }).call(this)).concat((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = missing.length; _i < _len; _i++) {
            x = missing[_i];
            _results.push(0);
          }
          return _results;
        })())
      };
    };

    Layer.prototype._stack = function(group) {
      var data, datas, item, key, tmp, yval, _results,
        _this = this;
      datas = poly.groupBy(this.statData, group);
      _results = [];
      for (key in datas) {
        data = datas[key];
        tmp = 0;
        yval = this.mapping.y != null ? (function(item) {
          return item[_this.mapping.y];
        }) : function(item) {
          return 0;
        };
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            item = data[_i];
            item.$lower = tmp;
            tmp += yval(item);
            _results1.push(item.$upper = tmp);
          }
          return _results1;
        })());
      }
      return _results;
    };

    Layer.prototype._dodge = function(group) {
      var aes, datas, groupAes, groupKey, item, key, numgroup, order, orderfn, values, yval, _i, _len, _ref, _results,
        _this = this;
      groupAes = _.without(_.keys(this.mapping), 'x', 'y', 'id');
      groupKey = _.toArray(_.pick(this.mapping, groupAes));
      yval = this.mapping.y != null ? (function(item) {
        return item[_this.mapping.y];
      }) : function(item) {
        return 0;
      };
      _ref = poly.groupBy(this.statData, group);
      _results = [];
      for (key in _ref) {
        datas = _ref[key];
        order = {};
        numgroup = 1;
        for (_i = 0, _len = groupAes.length; _i < _len; _i++) {
          aes = groupAes[_i];
          values = _.uniq((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = datas.length; _j < _len1; _j++) {
              item = datas[_j];
              _results1.push(this._getValue(item, aes));
            }
            return _results1;
          }).call(this));
          numgroup *= values.length;
          values.sort(poly.type.compare(this.meta[this.mapping[aes]].type));
          order[aes] = values;
        }
        orderfn = function(item) {
          var m, n, _j, _len1;
          m = numgroup;
          n = 0;
          for (_j = 0, _len1 = groupAes.length; _j < _len1; _j++) {
            aes = groupAes[_j];
            m /= order[aes].length;
            n += m * _.indexOf(order[aes], _this._getValue(item, aes));
          }
          return n;
        };
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = datas.length; _j < _len1; _j++) {
            item = datas[_j];
            item.$n = orderfn(item);
            _results1.push(item.$m = numgroup);
          }
          return _results1;
        })());
      }
      return _results;
    };

    return Layer;

  })();

  Point = (function(_super) {

    __extends(Point, _super);

    function Point() {
      return Point.__super__.constructor.apply(this, arguments);
    }

    Point.prototype._calcGeoms = function() {
      var evtData, idfn, item, k, v, _i, _len, _ref, _results;
      idfn = this._getIdFunc();
      this.geoms = {};
      _ref = this.statData;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        evtData = {};
        for (k in item) {
          v = item[k];
          evtData[k] = {
            "in": [v]
          };
        }
        _results.push(this.geoms[idfn(item)] = {
          marks: {
            0: {
              type: 'circle',
              x: this._getValue(item, 'x'),
              y: this._getValue(item, 'y'),
              color: this._getValue(item, 'color'),
              size: this._getValue(item, 'size'),
              opacity: this._getValue(item, 'opacity')
            }
          },
          evtData: evtData,
          tooltip: this._tooltip(item)
        });
      }
      return _results;
    };

    return Point;

  })(Layer);

  Path = (function(_super) {

    __extends(Path, _super);

    function Path() {
      return Path.__super__.constructor.apply(this, arguments);
    }

    Path.prototype._calcGeoms = function() {
      var data, datas, evtData, group, idfn, item, k, key, sample, _i, _len, _results;
      group = (function() {
        var _i, _len, _ref, _results;
        _ref = _.without(_.keys(this.mapping), 'x', 'y');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          _results.push(this.mapping[k]);
        }
        return _results;
      }).call(this);
      datas = poly.groupBy(this.statData, group);
      idfn = this._getIdFunc();
      this.geoms = {};
      _results = [];
      for (k in datas) {
        data = datas[k];
        sample = data[0];
        evtData = {};
        for (_i = 0, _len = group.length; _i < _len; _i++) {
          key = group[_i];
          evtData[key] = {
            "in": [sample[key]]
          };
        }
        _results.push(this.geoms[idfn(sample)] = {
          marks: {
            0: {
              type: 'path',
              x: (function() {
                var _j, _len1, _results1;
                _results1 = [];
                for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
                  item = data[_j];
                  _results1.push(this._getValue(item, 'x'));
                }
                return _results1;
              }).call(this),
              y: (function() {
                var _j, _len1, _results1;
                _results1 = [];
                for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
                  item = data[_j];
                  _results1.push(this._getValue(item, 'y'));
                }
                return _results1;
              }).call(this),
              color: this._getValue(sample, 'color'),
              opacity: this._getValue(sample, 'opacity')
            }
          },
          evtData: evtData
        });
      }
      return _results;
    };

    return Path;

  })(Layer);

  Line = (function(_super) {

    __extends(Line, _super);

    function Line() {
      return Line.__super__.constructor.apply(this, arguments);
    }

    Line.prototype._calcGeoms = function() {
      var all_x, data, datas, evtData, group, idfn, item, k, key, sample, x, y, _i, _len, _ref, _results;
      all_x = _.uniq((function() {
        var _i, _len, _ref, _results;
        _ref = this.statData;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          _results.push(this._getValue(item, 'x'));
        }
        return _results;
      }).call(this));
      group = (function() {
        var _i, _len, _ref, _results;
        _ref = _.without(_.keys(this.mapping), 'x', 'y');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          _results.push(this.mapping[k]);
        }
        return _results;
      }).call(this);
      datas = poly.groupBy(this.statData, group);
      idfn = this._getIdFunc();
      this.geoms = {};
      _results = [];
      for (k in datas) {
        data = datas[k];
        sample = data[0];
        evtData = {};
        for (_i = 0, _len = group.length; _i < _len; _i++) {
          key = group[_i];
          evtData[key] = {
            "in": [sample[key]]
          };
        }
        _ref = this._fillZeros(data, all_x), x = _ref.x, y = _ref.y;
        _results.push(this.geoms[idfn(sample)] = {
          marks: {
            0: {
              type: 'line',
              x: x,
              y: y,
              color: this._getValue(sample, 'color'),
              opacity: this._getValue(sample, 'opacity')
            }
          },
          evtData: evtData
        });
      }
      return _results;
    };

    return Line;

  })(Layer);

  Bar = (function(_super) {

    __extends(Bar, _super);

    function Bar() {
      return Bar.__super__.constructor.apply(this, arguments);
    }

    Bar.prototype._calcGeoms = function() {
      var m, _ref;
      if (this.mapping.x) {
        m = this.meta[this.mapping.x];
        if (m.type !== 'cat' && !m.binned) {
          console.log("Bar chart x-values need to be binned. Use the bin() transform!");
        }
      }
      this.position = (_ref = this.spec.position) != null ? _ref : 'stack';
      if (this.position === 'stack') {
        return this._calcGeomsStack();
      } else if (this.position === 'dodge') {
        return this._calcGeomsDodge();
      } else {
        throw poly.error.defn("Bar chart position " + this.position + " is unknown.");
      }
    };

    Bar.prototype._calcGeomsDodge = function() {
      var evtData, group, idfn, item, k, lower, upper, v, _i, _len, _ref, _results;
      group = this.mapping.x != null ? [this.mapping.x] : [];
      this._dodge(group);
      this._stack(group.concat("$n"));
      this.geoms = {};
      idfn = this._getIdFunc();
      _ref = this.statData;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        evtData = {};
        for (k in item) {
          v = item[k];
          if (k !== 'y') {
            evtData[k] = {
              "in": [v]
            };
          }
        }
        lower = sf.lower(this._getValue(item, 'x'), item.$n, item.$m);
        upper = sf.upper(this._getValue(item, 'x'), item.$n, item.$m);
        _results.push(this.geoms[idfn(item)] = {
          marks: {
            0: {
              type: 'rect',
              x: [lower, upper],
              y: [item.$lower, item.$upper],
              color: this._getValue(item, 'color'),
              opacity: this._getValue(item, 'opacity')
            }
          },
          evtData: evtData,
          tooltip: this._tooltip(item)
        });
      }
      return _results;
    };

    Bar.prototype._calcGeomsStack = function() {
      var evtData, group, idfn, item, k, v, _i, _len, _ref, _results;
      group = this.mapping.x != null ? [this.mapping.x] : [];
      this._stack(group);
      idfn = this._getIdFunc();
      this.geoms = {};
      _ref = this.statData;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        evtData = {};
        for (k in item) {
          v = item[k];
          if (k !== 'y') {
            evtData[k] = {
              "in": [v]
            };
          }
        }
        _results.push(this.geoms[idfn(item)] = {
          marks: {
            0: {
              type: 'rect',
              x: [sf.lower(this._getValue(item, 'x')), sf.upper(this._getValue(item, 'x'))],
              y: [item.$lower, item.$upper],
              color: this._getValue(item, 'color'),
              opacity: this._getValue(item, 'opacity')
            }
          },
          evtData: evtData,
          tooltip: this._tooltip(item)
        });
      }
      return _results;
    };

    return Bar;

  })(Layer);

  Area = (function(_super) {

    __extends(Area, _super);

    function Area() {
      return Area.__super__.constructor.apply(this, arguments);
    }

    Area.prototype._calcGeoms = function() {
      var all_x, counters, data, datas, evtData, group, idfn, item, k, key, sample, x, y, y_next, y_previous, _i, _j, _k, _len, _len1, _len2, _results;
      all_x = _.uniq((function() {
        var _i, _len, _ref, _results;
        _ref = this.statData;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          _results.push(this._getValue(item, 'x'));
        }
        return _results;
      }).call(this));
      counters = {};
      for (_i = 0, _len = all_x.length; _i < _len; _i++) {
        key = all_x[_i];
        counters[key] = 0;
      }
      group = (function() {
        var _j, _len1, _ref, _results;
        _ref = _.without(_.keys(this.mapping), 'x', 'y');
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          k = _ref[_j];
          _results.push(this.mapping[k]);
        }
        return _results;
      }).call(this);
      datas = poly.groupBy(this.statData, group);
      idfn = this._getIdFunc();
      this.geoms = {};
      _results = [];
      for (k in datas) {
        data = datas[k];
        sample = data[0];
        evtData = {};
        for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
          key = group[_j];
          evtData[key] = {
            "in": [sample[key]]
          };
        }
        y_previous = (function() {
          var _k, _len2, _results1;
          _results1 = [];
          for (_k = 0, _len2 = all_x.length; _k < _len2; _k++) {
            x = all_x[_k];
            _results1.push(counters[x]);
          }
          return _results1;
        })();
        for (_k = 0, _len2 = data.length; _k < _len2; _k++) {
          item = data[_k];
          x = this._getValue(item, 'x');
          y = this._getValue(item, 'y');
          counters[x] += y;
        }
        y_next = (function() {
          var _l, _len3, _results1;
          _results1 = [];
          for (_l = 0, _len3 = all_x.length; _l < _len3; _l++) {
            x = all_x[_l];
            _results1.push(counters[x]);
          }
          return _results1;
        })();
        _results.push(this.geoms[idfn(sample)] = {
          marks: {
            0: {
              type: 'area',
              x: all_x,
              y: {
                bottom: y_previous,
                top: y_next
              },
              color: this._getValue(sample, 'color'),
              opacity: this._getValue(sample, 'opacity')
            }
          },
          evtData: evtData
        });
      }
      return _results;
    };

    return Area;

  })(Layer);

  Text = (function(_super) {

    __extends(Text, _super);

    function Text() {
      return Text.__super__.constructor.apply(this, arguments);
    }

    Text.prototype._calcGeoms = function() {
      var evtData, idfn, item, k, v, _i, _len, _ref, _results;
      idfn = this._getIdFunc();
      this.geoms = {};
      _ref = this.statData;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        evtData = {};
        for (k in item) {
          v = item[k];
          evtData[k] = {
            "in": [v]
          };
        }
        _results.push(this.geoms[idfn(item)] = {
          marks: {
            0: {
              type: 'text',
              x: this._getValue(item, 'x'),
              y: this._getValue(item, 'y'),
              text: this._getValue(item, 'text'),
              color: this._getValue(item, 'color'),
              size: this._getValue(item, 'size'),
              opacity: this._getValue(item, 'opacity'),
              'text-anchor': 'center'
            }
          },
          evtData: evtData
        });
      }
      return _results;
    };

    return Text;

  })(Layer);

  Tile = (function(_super) {

    __extends(Tile, _super);

    function Tile() {
      return Tile.__super__.constructor.apply(this, arguments);
    }

    Tile.prototype._calcGeoms = function() {
      var evtData, idfn, item, k, v, x, y, _i, _len, _ref, _results;
      idfn = this._getIdFunc();
      this.geoms = {};
      _ref = this.statData;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        evtData = {};
        x = this._getValue(item, 'x');
        y = this._getValue(item, 'y');
        for (k in item) {
          v = item[k];
          if (k !== 'y' && k !== 'x') {
            evtData[k] = {
              "in": [v]
            };
          }
        }
        _results.push(this.geoms[idfn(item)] = {
          marks: {
            0: {
              type: 'rect',
              x: [sf.lower(this._getValue(item, 'x')), sf.upper(this._getValue(item, 'x'))],
              y: [sf.lower(this._getValue(item, 'y')), sf.upper(this._getValue(item, 'y'))],
              color: this._getValue(item, 'color'),
              size: this._getValue(item, 'size'),
              opacity: this._getValue(item, 'opacity')
            }
          },
          evtData: evtData,
          tooltip: this._tooltip(item)
        });
      }
      return _results;
    };

    return Tile;

  })(Layer);

  Box = (function(_super) {

    __extends(Box, _super);

    function Box() {
      return Box.__super__.constructor.apply(this, arguments);
    }

    Box.prototype._calcGeoms = function() {
      var color, evtData, geom, idfn, index, item, k, opacity, point, size, v, x, xl, xm, xu, y, _i, _j, _len, _len1, _ref, _ref1, _results;
      idfn = this._getIdFunc();
      this.geoms = {};
      _ref = this.statData;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        evtData = {};
        for (k in item) {
          v = item[k];
          if (k !== 'y') {
            evtData[k] = {
              "in": [v]
            };
          }
        }
        x = this._getValue(item, 'x');
        y = this._getValue(item, 'y');
        color = this._getValue(item, 'color');
        size = this._getValue(item, 'size');
        opacity = this._getValue(item, 'opacity');
        xl = sf.lower(x);
        xu = sf.upper(x);
        xm = sf.middle(x);
        geom = {
          marks: {},
          evtData: evtData
        };
        if (y.q1) {
          geom.marks = {
            iqr: {
              type: 'rect',
              x: [xl, xu],
              y: [y.q2, y.q4],
              stroke: color,
              color: sf.identity('white'),
              size: size,
              opacity: opacity,
              'stroke-width': '1px'
            },
            q1: {
              type: 'pline',
              x: [xl, xu],
              y: [y.q1, y.q1],
              color: color,
              size: size,
              opacity: opacity
            },
            lower: {
              type: 'pline',
              x: [xm, xm],
              y: [y.q1, y.q2],
              color: color,
              size: size,
              opacity: opacity
            },
            q5: {
              type: 'pline',
              x: [xl, xu],
              y: [y.q5, y.q5],
              color: color,
              size: size,
              opacity: opacity
            },
            upper: {
              type: 'pline',
              x: [xm, xm],
              y: [y.q4, y.q5],
              color: color,
              size: size,
              opacity: opacity
            },
            middle: {
              type: 'pline',
              x: [xl, xu],
              y: [y.q3, y.q3],
              color: color,
              size: size,
              opacity: opacity
            }
          };
        }
        _ref1 = y.outliers;
        for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
          point = _ref1[index];
          geom.marks[index] = {
            type: 'circle',
            x: xm,
            y: point,
            color: color,
            size: sf.identity(3),
            opacity: opacity
          };
        }
        _results.push(this.geoms[idfn(item)] = geom);
      }
      return _results;
    };

    return Box;

  })(Layer);

  /*
  Public interface to making different layer types.
  TODO: this should be changed to make it easier to make other
        types of layers.
  */


  poly.layer = {};

  poly.layer.classes = {
    'point': Point,
    'text': Text,
    'line': Line,
    'path': Path,
    'area': Area,
    'bar': Bar,
    'tile': Tile,
    'box': Box
  };

  poly.layer.make = function(layerSpec, strictmode) {
    var type;
    type = layerSpec.type;
    if (type in poly.layer.classes) {
      return new poly.layer.classes[type](layerSpec, strictmode);
    }
    throw poly.error.defn("No such layer " + layerSpec.type + ".");
  };

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var Pane,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  poly.pane = {};

  poly.pane.make = function(spec, grp, formatter) {
    return new Pane(spec, grp, formatter);
  };

  Pane = (function(_super) {

    __extends(Pane, _super);

    function Pane(spec, multiindex, formatter) {
      this.spec = spec;
      this.index = multiindex;
      this.str = formatter(multiindex);
      this.layers = null;
      this.title = null;
    }

    Pane.prototype.make = function(spec, data) {
      var geoms, i, layer, meta, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      this.layers = this._makeLayers(spec);
      if (!this.geoms) {
        this.geoms = {};
        _ref = this.layers;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          layer = _ref[i];
          this.geoms[i] = new poly.Geometry();
        }
      }
      this.metas = {};
      _ref1 = this.layers;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        layer = _ref1[i];
        _ref2 = layer.calculate(data[i].statData, data[i].metaData), geoms = _ref2.geoms, meta = _ref2.meta;
        this.geoms[i].set(geoms);
        this.metas[i] = meta;
      }
      if ((_ref3 = this.title) == null) {
        this.title = this._makeTitle(spec);
      }
      this.title.make({
        title: this.str
      });
      return this.domains = this._makeDomains(spec, this.geoms, this.metas);
    };

    Pane.prototype._makeTitle = function() {
      return poly.guide.title('facet');
    };

    Pane.prototype._makeLayers = function(spec) {
      return _.map(spec.layers, function(layerSpec) {
        return poly.layer.make(layerSpec, spec.strict);
      });
    };

    Pane.prototype._makeDomains = function(spec, geoms, metas) {
      return poly.domain.make(geoms, metas, spec.guides, spec.strict);
    };

    Pane.prototype.render = function(renderer, offset, clipping, dims) {
      var geom, k, r, _ref, _results;
      this.title.render(renderer({}, false, false), dims, offset);
      r = renderer(offset, clipping, true);
      _ref = this.geoms;
      _results = [];
      for (k in _ref) {
        geom = _ref[k];
        _results.push(geom.render(r));
      }
      return _results;
    };

    Pane.prototype.dispose = function(renderer) {
      var layer, _i, _len, _ref;
      _ref = this.layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        layer.dispose(renderer);
      }
      return this.title.dispose(renderer);
    };

    return Pane;

  })(poly.Renderable);

}).call(this);
// Generated by CoffeeScript 1.4.0

/*
DIMENSIONS
----------
Calculate the pixel dimension and layout of a particular chart
*/


(function() {

  poly.dim = {};

  poly.dim.make = function(spec, scaleSet, facetGrid) {
    var bottom, dim, left, right, top, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    dim = {
      width: (_ref = spec.width) != null ? _ref : 400,
      height: (_ref1 = spec.height) != null ? _ref1 : 400,
      paddingLeft: (_ref2 = spec.paddingLeft) != null ? _ref2 : 10,
      paddingRight: (_ref3 = spec.paddingRight) != null ? _ref3 : 10,
      paddingTop: (_ref4 = spec.paddingTop) != null ? _ref4 : 10,
      paddingBottom: (_ref5 = spec.paddingBottom) != null ? _ref5 : 10,
      horizontalSpacing: (_ref6 = spec.horizontalSpacing) != null ? _ref6 : 10,
      verticalSpacing: (_ref7 = spec.verticalSpacing) != null ? _ref7 : 20,
      guideTop: 10,
      guideRight: 0,
      guideLeft: 5,
      guideBottom: 5
    };
    _ref8 = scaleSet.axesOffset(dim), left = _ref8.left, right = _ref8.right, top = _ref8.top, bottom = _ref8.bottom;
    dim.guideLeft += left != null ? left : 0;
    dim.guideRight += right != null ? right : 0;
    dim.guideBottom += bottom != null ? bottom : 0;
    dim.guideTop += top != null ? top : 0;
    _ref9 = scaleSet.titleOffset(dim), left = _ref9.left, right = _ref9.right, top = _ref9.top, bottom = _ref9.bottom;
    dim.guideLeft += left != null ? left : 0;
    dim.guideRight += right != null ? right : 0;
    dim.guideBottom += bottom != null ? bottom : 0;
    dim.guideTop += top != null ? top : 0;
    _ref10 = scaleSet.legendOffset(dim), left = _ref10.left, right = _ref10.right, top = _ref10.top, bottom = _ref10.bottom;
    dim.guideLeft += left != null ? left : 0;
    dim.guideRight += right != null ? right : 0;
    dim.guideBottom += bottom != null ? bottom : 0;
    dim.guideTop += top != null ? top : 0;
    dim.chartHeight = dim.height - dim.paddingTop - dim.paddingBottom - dim.guideTop - dim.guideBottom;
    dim.chartWidth = dim.width - dim.paddingLeft - dim.paddingRight - dim.guideLeft - dim.guideRight;
    if ((facetGrid.cols != null) && facetGrid.cols > 1) {
      dim.chartWidth -= dim.horizontalSpacing * facetGrid.cols;
      dim.chartWidth /= facetGrid.cols;
    }
    if ((facetGrid.rows != null) && facetGrid.rows > 1) {
      dim.chartHeight -= dim.verticalSpacing * (facetGrid.rows + 1);
      dim.chartHeight /= facetGrid.rows;
    } else {
      dim.chartHeight -= dim.verticalSpacing;
    }
    return dim;
  };

  poly.dim.guess = function(spec, facetGrid) {
    var dim, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    dim = {
      width: (_ref = spec.width) != null ? _ref : 400,
      height: (_ref1 = spec.height) != null ? _ref1 : 400,
      paddingLeft: (_ref2 = spec.paddingLeft) != null ? _ref2 : 10,
      paddingRight: (_ref3 = spec.paddingRight) != null ? _ref3 : 10,
      paddingTop: (_ref4 = spec.paddingTop) != null ? _ref4 : 10,
      paddingBottom: (_ref5 = spec.paddingBottom) != null ? _ref5 : 10,
      guideLeft: 30,
      guideRight: 40,
      guideTop: 10,
      guideBottom: 30,
      horizontalSpacing: (_ref6 = spec.horizontalSpacing) != null ? _ref6 : 10,
      verticalSpacing: (_ref7 = spec.verticalSpacing) != null ? _ref7 : 10
    };
    dim.chartHeight = dim.height - dim.paddingTop - dim.paddingBottom - dim.guideTop - dim.guideBottom;
    dim.chartWidth = dim.width - dim.paddingLeft - dim.paddingRight - dim.guideLeft - dim.guideRight;
    if ((facetGrid.cols != null) && facetGrid.cols > 1) {
      dim.chartWidth -= dim.horizontalSpacing * (facetGrid.cols - 1);
    }
    if ((facetGrid.rows != null) && facetGrid.rows > 1) {
      dim.chartHeight -= dim.verticalSpacing * (facetGrid.rows - 1);
    }
    return dim;
  };

  /*
  # CLASSES
  */


}).call(this);
// Generated by CoffeeScript 1.4.0

/*
# GLOBALS
*/


(function() {
  var Area, Circle, CircleRect, Line, Path, PolarLine, Rect, Renderer, Text, renderer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  poly.paper = function(dom, w, h, handleEvent) {
    var applyOffset, bg, end, handler, offset, onend, onmove, onstart, paper, start;
    if (!(typeof Raphael !== "undefined" && Raphael !== null)) {
      throw poly.error.depn("The dependency Raphael is not included.");
    }
    paper = Raphael(dom, w, h);
    bg = paper.rect(0, 0, w, h).attr({
      fill: 'white',
      opacity: 0,
      'stroke-width': 0
    });
    bg.click(handleEvent('reset'));
    handler = handleEvent('select');
    offset = poly.offset(dom);
    applyOffset = function(x, y) {
      return {
        x: x - offset.left,
        y: y - offset.top
      };
    };
    start = end = null;
    onstart = function() {
      start = null;
      return end = null;
    };
    onmove = function(dx, dy, y, x) {
      if (start != null) {
        return end = applyOffset(x, y);
      } else {
        return start = applyOffset(x, y);
      }
    };
    onend = function() {
      if ((start != null) && (end != null)) {
        return handler({
          start: start,
          end: end
        });
      }
    };
    bg.drag(onmove, onstart, onend);
    return paper;
  };

  /*
  Helper function for rendering all the geoms of an object
  */


  poly.render = function(handleEvent, paper, scales, coord) {
    return function(offset, clipping, mayflip) {
      if (offset == null) {
        offset = {};
      }
      if (clipping == null) {
        clipping = false;
      }
      if (mayflip == null) {
        mayflip = true;
      }
      return {
        add: function(mark, evtData, tooltip) {
          var pt;
          if (!(coord.type != null)) {
            throw poly.error.unknown("Coordinate don't have at type?");
          }
          if (!(renderer[coord.type] != null)) {
            throw poly.error.input("Unknown coordinate type " + coord.type);
          }
          if (!(renderer[coord.type][mark.type] != null)) {
            throw poly.error.input("Coord " + coord.type + " has no mark " + mark.type);
          }
          pt = renderer[coord.type][mark.type].render(paper, scales, coord, offset, mark, mayflip);
          if (clipping != null) {
            pt.attr('clip-rect', clipping);
          }
          if (evtData && _.keys(evtData).length > 0) {
            pt.data('e', evtData);
          }
          if (tooltip) {
            pt.data('t', tooltip);
          }
          pt.click(handleEvent('click'));
          pt.hover(handleEvent('mover'), handleEvent('mout'));
          return pt;
        },
        remove: function(pt) {
          return pt.remove();
        },
        animate: function(pt, mark, evtData, tooltip) {
          renderer[coord.type][mark.type].animate(pt, scales, coord, offset, mark, mayflip);
          if (evtData && _.keys(evtData).length > 0) {
            pt.data('e', evtData);
          }
          if (tooltip) {
            pt.data('t', tooltip);
          }
          return pt;
        }
      };
    };
  };

  Renderer = (function() {

    function Renderer() {}

    Renderer.prototype.render = function(paper, scales, coord, offset, mark, mayflip) {
      var k, pt, v, _ref;
      pt = this._make(paper);
      _ref = this.attr(scales, coord, offset, mark, mayflip);
      for (k in _ref) {
        v = _ref[k];
        pt.attr(k, v);
      }
      return pt;
    };

    Renderer.prototype._make = function() {
      throw poly.error.impl();
    };

    Renderer.prototype.animate = function(pt, scales, coord, offset, mark, mayflip) {
      return pt.animate(this.attr(scales, coord, offset, mark, mayflip), 300);
    };

    Renderer.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      throw poly.error.impl();
    };

    Renderer.prototype._makePath = function(xs, ys, type) {
      var path;
      if (type == null) {
        type = 'L';
      }
      path = _.map(xs, function(x, i) {
        return (i === 0 ? 'M' : type) + x + ' ' + ys[i];
      });
      return path.join(' ');
    };

    Renderer.prototype._maybeApply = function(scales, mark, key) {
      var val;
      val = mark[key];
      if (_.isObject(val) && val.f === 'identity') {
        return val.v;
      } else if (scales[key] != null) {
        return scales[key].f(val);
      } else {
        return val;
      }
    };

    Renderer.prototype._applyOffset = function(x, y, offset) {
      var i, _ref, _ref1;
      if (!offset) {
        return {
          x: x,
          y: y
        };
      }
      if ((_ref = offset.x) == null) {
        offset.x = 0;
      }
      if ((_ref1 = offset.y) == null) {
        offset.y = 0;
      }
      return {
        x: _.isArray(x) ? (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = x.length; _i < _len; _i++) {
            i = x[_i];
            _results.push(i + offset.x);
          }
          return _results;
        })() : x + offset.x,
        y: _.isArray(y) ? (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = y.length; _i < _len; _i++) {
            i = y[_i];
            _results.push(i + offset.y);
          }
          return _results;
        })() : y + offset.y
      };
    };

    Renderer.prototype._shared = function(scales, mark, attr) {
      var maybeAdd,
        _this = this;
      maybeAdd = function(aes) {
        if ((mark[aes] != null) && !(attr[aes] != null)) {
          return attr[aes] = _this._maybeApply(scales, mark, aes);
        }
      };
      maybeAdd('opacity');
      maybeAdd('stroke-width');
      maybeAdd('stroke-dasharray');
      maybeAdd('stroke-dashoffset');
      maybeAdd('transform');
      maybeAdd('font-size');
      maybeAdd('font-weight');
      maybeAdd('font-family');
      return attr;
    };

    return Renderer;

  })();

  Circle = (function(_super) {

    __extends(Circle, _super);

    function Circle() {
      return Circle.__super__.constructor.apply(this, arguments);
    }

    Circle.prototype._make = function(paper) {
      return paper.circle();
    };

    Circle.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      var attr, fill, stroke, x, y, _ref, _ref1;
      _ref = coord.getXY(mayflip, mark), x = _ref.x, y = _ref.y;
      _ref1 = this._applyOffset(x, y, offset), x = _ref1.x, y = _ref1.y;
      stroke = this._maybeApply(scales, mark, mark.stroke ? 'stroke' : 'color');
      attr = {
        cx: x,
        cy: y,
        r: this._maybeApply(scales, mark, 'size'),
        stroke: stroke
      };
      fill = this._maybeApply(scales, mark, 'color');
      if (fill && fill !== 'none') {
        attr.fill = fill;
      }
      return this._shared(scales, mark, attr);
    };

    return Circle;

  })(Renderer);

  Path = (function(_super) {

    __extends(Path, _super);

    function Path() {
      return Path.__super__.constructor.apply(this, arguments);
    }

    Path.prototype._make = function(paper) {
      return paper.path();
    };

    Path.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      var stroke, x, y, _ref, _ref1;
      _ref = coord.getXY(mayflip, mark), x = _ref.x, y = _ref.y;
      _ref1 = this._applyOffset(x, y, offset), x = _ref1.x, y = _ref1.y;
      stroke = this._maybeApply(scales, mark, mark.stroke ? 'stroke' : 'color');
      return this._shared(scales, mark, {
        path: this._makePath(x, y),
        stroke: stroke
      });
    };

    return Path;

  })(Renderer);

  Line = (function(_super) {

    __extends(Line, _super);

    function Line() {
      return Line.__super__.constructor.apply(this, arguments);
    }

    Line.prototype._make = function(paper) {
      return paper.path();
    };

    Line.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      var stroke, x, y, _ref, _ref1, _ref2;
      _ref = poly.sortArrays(scales.x.compare, [mark.x, mark.y]), mark.x = _ref[0], mark.y = _ref[1];
      _ref1 = coord.getXY(mayflip, mark), x = _ref1.x, y = _ref1.y;
      _ref2 = this._applyOffset(x, y, offset), x = _ref2.x, y = _ref2.y;
      stroke = this._maybeApply(scales, mark, mark.stroke ? 'stroke' : 'color');
      return this._shared(scales, mark, {
        path: this._makePath(x, y),
        stroke: stroke
      });
    };

    return Line;

  })(Renderer);

  PolarLine = (function(_super) {

    __extends(PolarLine, _super);

    function PolarLine() {
      return PolarLine.__super__.constructor.apply(this, arguments);
    }

    PolarLine.prototype._make = function(paper) {
      return paper.path();
    };

    PolarLine.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      var dir, i, large, path, r, stroke, t, x, y, _ref, _ref1;
      _ref = coord.getXY(mayflip, mark), x = _ref.x, y = _ref.y, r = _ref.r, t = _ref.t;
      _ref1 = this._applyOffset(x, y, offset), x = _ref1.x, y = _ref1.y;
      path = (function() {
        var _i, _ref2;
        if (_.max(r) - _.min(r) < poly["const"].epsilon) {
          r = r[0];
          path = "M " + x[0] + " " + y[0];
          for (i = _i = 1, _ref2 = x.length - 1; 1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 1 <= _ref2 ? ++_i : --_i) {
            large = Math.abs(t[i] - t[i - 1]) > Math.PI ? 1 : 0;
            dir = t[i] - t[i - 1] > 0 ? 1 : 0;
            path += "A " + r + " " + r + " 0 " + large + " " + dir + " " + x[i] + " " + y[i];
          }
          return path;
        } else {
          return this._makePath(x, y);
        }
      }).call(this);
      stroke = this._maybeApply(scales, mark, mark.stroke ? 'stroke' : 'color');
      return this._shared(scales, mark, {
        path: path,
        stroke: stroke
      });
    };

    return PolarLine;

  })(Renderer);

  Area = (function(_super) {

    __extends(Area, _super);

    function Area() {
      return Area.__super__.constructor.apply(this, arguments);
    }

    Area.prototype._make = function(paper) {
      return paper.path();
    };

    Area.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      var bottom, top, x, y, _ref, _ref1;
      _ref = poly.sortArrays(scales.x.compare, [mark.x, mark.y.top]), x = _ref[0], y = _ref[1];
      top = coord.getXY(mayflip, {
        x: x,
        y: y
      });
      top = this._applyOffset(top.x, top.y, offset);
      _ref1 = poly.sortArrays((function(a, b) {
        return -scales.x.compare(a, b);
      }), [mark.x, mark.y.bottom]), x = _ref1[0], y = _ref1[1];
      bottom = coord.getXY(mayflip, {
        x: x,
        y: y
      });
      bottom = this._applyOffset(bottom.x, bottom.y, offset);
      x = top.x.concat(bottom.x);
      y = top.y.concat(bottom.y);
      return this._shared(scales, mark, {
        path: this._makePath(x, y),
        stroke: this._maybeApply(scales, mark, 'color'),
        fill: this._maybeApply(scales, mark, 'color'),
        'stroke-width': '0px'
      });
    };

    return Area;

  })(Renderer);

  Rect = (function(_super) {

    __extends(Rect, _super);

    function Rect() {
      return Rect.__super__.constructor.apply(this, arguments);
    }

    Rect.prototype._make = function(paper) {
      return paper.rect();
    };

    Rect.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      var stroke, x, y, _ref, _ref1;
      _ref = coord.getXY(mayflip, mark), x = _ref.x, y = _ref.y;
      _ref1 = this._applyOffset(x, y, offset), x = _ref1.x, y = _ref1.y;
      stroke = this._maybeApply(scales, mark, mark.stroke ? 'stroke' : 'color');
      return this._shared(scales, mark, {
        x: _.min(x),
        y: _.min(y),
        width: Math.abs(x[1] - x[0]),
        height: Math.abs(y[1] - y[0]),
        fill: this._maybeApply(scales, mark, 'color'),
        stroke: stroke,
        'stroke-width': this._maybeApply(scales, mark, 'stroke-width' != null ? 'stroke-width' : '0px')
      });
    };

    return Rect;

  })(Renderer);

  CircleRect = (function(_super) {

    __extends(CircleRect, _super);

    function CircleRect() {
      return CircleRect.__super__.constructor.apply(this, arguments);
    }

    CircleRect.prototype._make = function(paper) {
      return paper.path();
    };

    CircleRect.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      var large, path, r, stroke, t, x, x0, x1, y, y0, y1, _ref, _ref1, _ref2, _ref3;
      _ref = mark.x, x0 = _ref[0], x1 = _ref[1];
      _ref1 = mark.y, y0 = _ref1[0], y1 = _ref1[1];
      mark.x = [x0, x0, x1, x1];
      mark.y = [y0, y1, y1, y0];
      _ref2 = coord.getXY(mayflip, mark), x = _ref2.x, y = _ref2.y, r = _ref2.r, t = _ref2.t;
      _ref3 = this._applyOffset(x, y, offset), x = _ref3.x, y = _ref3.y;
      if (coord.flip) {
        x.push(x.splice(0, 1)[0]);
        y.push(y.splice(0, 1)[0]);
        r.push(r.splice(0, 1)[0]);
        t.push(t.splice(0, 1)[0]);
      }
      large = Math.abs(t[1] - t[0]) > Math.PI ? 1 : 0;
      path = "M " + x[0] + " " + y[0] + " A " + r[0] + " " + r[0] + " 0 " + large + " 1 " + x[1] + " " + y[1];
      large = Math.abs(t[3] - t[2]) > Math.PI ? 1 : 0;
      path += "L " + x[2] + " " + y[2] + " A " + r[2] + " " + r[2] + " 0 " + large + " 0 " + x[3] + " " + y[3] + " Z";
      stroke = this._maybeApply(scales, mark, mark.stroke ? 'stroke' : 'color');
      return this._shared(scales, mark, {
        path: path,
        fill: this._maybeApply(scales, mark, 'color'),
        stroke: stroke,
        'stroke-width': this._maybeApply(scales, mark, 'stroke-width' != null ? 'stroke-width' : '0px')
      });
    };

    return CircleRect;

  })(Renderer);

  Text = (function(_super) {

    __extends(Text, _super);

    function Text() {
      return Text.__super__.constructor.apply(this, arguments);
    }

    Text.prototype._make = function(paper) {
      return paper.text();
    };

    Text.prototype.attr = function(scales, coord, offset, mark, mayflip) {
      var x, y, _ref, _ref1, _ref2;
      _ref = coord.getXY(mayflip, mark), x = _ref.x, y = _ref.y;
      _ref1 = this._applyOffset(x, y, offset), x = _ref1.x, y = _ref1.y;
      return this._shared(scales, mark, {
        x: x,
        y: y,
        r: 10,
        text: this._maybeApply(scales, mark, 'text'),
        'text-anchor': (_ref2 = mark['text-anchor']) != null ? _ref2 : 'left',
        fill: this._maybeApply(scales, mark, 'color') || 'black'
      });
    };

    return Text;

  })(Renderer);

  renderer = {
    cartesian: {
      circle: new Circle(),
      line: new Line(),
      pline: new Line(),
      area: new Area(),
      path: new Path(),
      text: new Text(),
      rect: new Rect()
    },
    polar: {
      circle: new Circle(),
      path: new Path(),
      line: new Line(),
      pline: new PolarLine(),
      area: new Area(),
      text: new Text(),
      rect: new CircleRect()
    }
  };

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {

  poly.handler = {};

  poly.handler.tooltip = function() {
    var tooltip;
    tooltip = {};
    return function(type, obj, event) {
      var height, paper, width, x, x1, x2, y, y1, y2, _ref, _ref1, _ref2;
      if (type === 'mover' || type === 'mout') {
        if (tooltip.text != null) {
          tooltip.text.remove();
          tooltip.box.remove();
        }
        tooltip = {};
        if (type === 'mover' && obj.tooltip) {
          paper = obj.paper;
          _ref = obj.getBBox(), x = _ref.x, y = _ref.y, x2 = _ref.x2, y2 = _ref.y2;
          y1 = y;
          x1 = x / 2 + x2 / 2;
          tooltip.text = paper.text(x1, y1, obj.tooltip).attr({
            'text-anchor': 'middle',
            'fill': 'white'
          });
          _ref1 = tooltip.text.getBBox(), x = _ref1.x, y = _ref1.y, width = _ref1.width, height = _ref1.height;
          y = (y1 - height) + 4;
          tooltip.text.attr({
            'y': y
          });
          _ref2 = tooltip.text.getBBox(), x = _ref2.x, y = _ref2.y, width = _ref2.width, height = _ref2.height;
          tooltip.box = paper.rect(x - 5, y - 5, width + 10, height + 10, 5);
          tooltip.box.attr({
            fill: '#213'
          });
          return tooltip.text.toFront();
        }
      }
    };
  };

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var Facet, Grid, NoFacet, Wrap,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  poly.facet = {};

  poly.facet.make = function(spec) {
    if (!(spec != null) || !(spec.type != null)) {
      return new NoFacet();
    }
    switch (spec.type) {
      case 'wrap':
        return new Wrap(spec);
      case 'grid':
        return new Grid(spec);
      default:
        throw poly.error.defn("No such facet type " + spec.type + ".");
    }
  };

  Facet = (function() {

    function Facet(spec) {
      var _ref;
      this.spec = spec;
      this.values = {};
      this.groups = [];
      this.indices = {};
      if ((_ref = this.spec) == null) {
        this.spec = {};
      }
    }

    Facet.prototype.getIndices = function(datas) {
      var data, index, indexValues, key, stringify, v, val, _i, _j, _len, _len1, _ref;
      this.values = {};
      _ref = this.groups;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        if (key.levels) {
          this.values[key["var"]] = key.levels;
        } else {
          v = [];
          for (index in datas) {
            data = datas[index];
            if (key["var"] in data.metaData) {
              v = _.union(v, _.uniq(_.pluck(data.statData, key["var"])));
            }
          }
          this.values[key["var"]] = v;
        }
      }
      indexValues = poly.cross(this.values);
      this.indices = {};
      stringify = poly.stringify(_.pluck(this.groups, 'var'));
      for (_j = 0, _len1 = indexValues.length; _j < _len1; _j++) {
        val = indexValues[_j];
        this.indices[stringify(val)] = val;
      }
      return this.indices;
    };

    Facet.prototype.getFormatter = function() {
      var formatters, k;
      if (!this.formatter) {
        this.formatter = (function() {
          var _i, _len, _ref;
          if (this.spec.formatter) {
            return this.spec.formatter;
          } else {
            formatters = {};
            _ref = this.groups;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              k = _ref[_i];
              formatters[k["var"]] = k.formatter ? k.formatter : poly.format.value;
            }
            return function(multiindex) {
              var str, v;
              str = '';
              for (k in multiindex) {
                v = multiindex[k];
                if (str) {
                  str += ", ";
                }
                str += "" + k + ": " + (formatters[k](v));
              }
              return str;
            };
          }
        }).call(this);
      }
      return this.formatter;
    };

    Facet.prototype.groupData = function(unfaceted) {
      var datas, groupedData, groups, id, mindex, pointer, value, _ref;
      if (!this.indices) {
        this.getIndices(unfacted);
      }
      datas = {};
      groups = _.pluck(this.groups, 'var');
      groupedData = poly.groupProcessedData(unfaceted, groups);
      _ref = this.indices;
      for (id in _ref) {
        mindex = _ref[id];
        pointer = groupedData;
        while (pointer.grouped === true) {
          value = mindex[pointer.key];
          pointer = pointer.values[value];
        }
        datas[id] = pointer;
      }
      return datas;
    };

    Facet.prototype.getOffset = function(dims, col, row) {
      return {
        x: dims.paddingLeft + dims.guideLeft + (dims.chartWidth + dims.horizontalSpacing) * col,
        y: dims.paddingTop + dims.guideTop + (dims.chartHeight + dims.verticalSpacing) * row + dims.verticalSpacing
      };
    };

    Facet.prototype.getFacetInfo = function(dims, x, y) {
      var col, offsetX, offsetY, row;
      col = (x - dims.paddingLeft - dims.guideLeft) / (dims.chartWidth + dims.horizontalSpacing);
      col = Math.floor(col);
      offsetX = dims.paddingLeft + dims.guideLeft + (dims.chartWidth + dims.horizontalSpacing) * col;
      row = (y - dims.paddingTop - dims.guideTop - dims.verticalSpacing) / (dims.chartHeight + dims.verticalSpacing);
      row = Math.floor(row);
      offsetY = dims.paddingTop + dims.guideTop + (dims.chartHeight + dims.verticalSpacing) * row + dims.verticalSpacing;
      if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) {
        return null;
      } else if (x - offsetX > dims.chartWidth || y - offsetY > dims.chartHeight) {
        return null;
      } else {
        return {
          col: col,
          row: row,
          evtData: this.getEvtData(col, row),
          offset: {
            x: offsetX,
            y: offsetY
          }
        };
      }
    };

    Facet.prototype.getGrid = function() {
      throw poly.error.impl();
    };

    Facet.prototype.edge = function(dir, col, row) {
      var acc, edge, grp, key, m, n, optimize;
      if (dir === 'none') {
        return function() {
          return false;
        };
      }
      if (dir === 'out') {
        return function() {
          return true;
        };
      }
      grp = dir === 'top' || dir === 'bottom' ? col : row;
      optimize = dir === 'top' ? row : dir === 'bottom' ? function(k) {
        return -row(k);
      } : dir === 'left' ? col : dir === 'right' ? function(k) {
        return -col(k);
      } : void 0;
      acc = {};
      for (key in this.indices) {
        n = grp(key);
        m = optimize(key);
        if (!acc[n] || m < acc[n].v) {
          acc[n] = {
            v: m,
            k: key
          };
        }
      }
      edge = _.pluck(acc, 'k');
      return function(identifier) {
        return __indexOf.call(edge, identifier) >= 0;
      };
    };

    Facet.prototype.getEvtData = function() {
      throw poly.error.impl();
    };

    return Facet;

  })();

  NoFacet = (function(_super) {

    __extends(NoFacet, _super);

    function NoFacet() {
      return NoFacet.__super__.constructor.apply(this, arguments);
    }

    NoFacet.prototype.cols = 1;

    NoFacet.prototype.rows = 1;

    NoFacet.prototype.getOffset = function(dims) {
      return NoFacet.__super__.getOffset.call(this, dims, 0, 0);
    };

    NoFacet.prototype.getGrid = function() {
      return {
        cols: 1,
        rows: 1
      };
    };

    NoFacet.prototype.edge = function(dir) {
      return function() {
        return true;
      };
    };

    NoFacet.prototype.getEvtData = function(col, row) {
      return {};
    };

    return NoFacet;

  })(Facet);

  Wrap = (function(_super) {

    __extends(Wrap, _super);

    function Wrap(spec) {
      this.spec = spec;
      Wrap.__super__.constructor.call(this, this.spec);
      if (!this.spec["var"]) {
        throw poly.error.defn("You didn't specify a variable to facet on.");
      }
      this["var"] = this.spec["var"];
      this.groups = [this["var"]];
    }

    Wrap.prototype.getGrid = function() {
      var numFacets;
      if (!this.values || !this.indices) {
        throw poly.error.input("Need to run getIndices first!");
      }
      this.cols = this.spec.cols;
      this.rows = this.spec.rows;
      numFacets = this.values[this["var"]["var"]].length;
      if (!this.cols && !this.rows) {
        this.cols = Math.min(3, numFacets);
      }
      if (this.cols) {
        this.rows = Math.ceil(numFacets / this.cols);
      } else if (this.rows) {
        this.cols = Math.ceil(numFacets / this.rows);
      }
      return {
        cols: this.cols,
        rows: this.rows
      };
    };

    Wrap.prototype.edge = function(dir) {
      var col, row,
        _this = this;
      col = function(id) {
        return _.indexOf(_this.values[_this["var"]["var"]], _this.indices[id][_this["var"]["var"]]) % _this.cols;
      };
      row = function(id) {
        return Math.floor(_.indexOf(_this.values[_this["var"]["var"]], _this.indices[id][_this["var"]["var"]]) / _this.cols);
      };
      return Wrap.__super__.edge.call(this, dir, col, row);
    };

    Wrap.prototype.getOffset = function(dims, identifier) {
      var id, value;
      value = this.indices[identifier][this["var"]["var"]];
      id = _.indexOf(this.values[this["var"]["var"]], value);
      return Wrap.__super__.getOffset.call(this, dims, id % this.cols, Math.floor(id / this.cols));
    };

    Wrap.prototype.getEvtData = function(col, row) {
      var obj;
      obj = {};
      obj[this["var"]["var"]] = {
        "in": [this.values[this["var"]["var"]][this.rows * row + col]]
      };
      return obj;
    };

    return Wrap;

  })(Facet);

  Grid = (function(_super) {

    __extends(Grid, _super);

    function Grid(spec) {
      this.spec = spec;
      Grid.__super__.constructor.call(this, this.spec);
      if (!this.spec.x && this.spec.y) {
        throw poly.error.defn("You didn't specify a variable to facet on.");
      }
      this.x = this.spec.x;
      this.y = this.spec.y;
      this.groups = _.compact([this.x, this.y]);
    }

    Grid.prototype.getGrid = function() {
      if (!this.values || !this.indices) {
        throw poly.error.input("Need to run getIndices first!");
      }
      return {
        cols: this.x ? this.values[this.x["var"]].length : 1,
        rows: this.y ? this.values[this.y["var"]].length : 1
      };
    };

    Grid.prototype.edge = function(dir) {
      var col, row,
        _this = this;
      row = function(id) {
        return _.indexOf(_this.values[_this.y["var"]], _this.indices[id][_this.y["var"]]);
      };
      col = function(id) {
        return _.indexOf(_this.values[_this.x["var"]], _this.indices[id][_this.x["var"]]);
      };
      return Grid.__super__.edge.call(this, dir, col, row);
    };

    Grid.prototype.getOffset = function(dims, identifier) {
      var col, row;
      if (!this.values || !this.indices) {
        throw poly.error.input("Need to run getIndices first!");
      }
      row = _.indexOf(this.values[this.y["var"]], this.indices[identifier][this.y["var"]]);
      col = _.indexOf(this.values[this.x["var"]], this.indices[identifier][this.x["var"]]);
      return Grid.__super__.getOffset.call(this, dims, col, row);
    };

    Grid.prototype.getEvtData = function(col, row) {
      var obj;
      obj = {};
      obj[this.x["var"]] = {
        "in": this.values[this.x["var"]][col]
      };
      obj[this.y["var"]] = {
        "in": this.values[this.y["var"]][row]
      };
      return obj;
    };

    return Grid;

  })(Facet);

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var Graph,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Graph = (function() {
    /*
      The constructor does not do any real work. It just sets a bunch of variables
      to its default value and call @make(), which actually does the real work.
    */

    function Graph(spec) {
      this.handleEvent = __bind(this.handleEvent, this);

      this.render = __bind(this.render, this);

      this.mergeDomains = __bind(this.mergeDomains, this);

      this.makePanes = __bind(this.makePanes, this);

      this.merge = __bind(this.merge, this);

      this.needDispose = __bind(this.needDispose, this);

      this.reset = __bind(this.reset, this);
      if (!(spec != null)) {
        throw poly.error.defn("No graph specification is passed in!");
      }
      this.handlers = [];
      this.panes = null;
      this.scaleSet = null;
      this.axes = null;
      this.legends = null;
      this.dims = null;
      this.paper = null;
      this.coord = null;
      this.facet = null;
      this.initial_spec = spec;
      this.dataSubscribed = false;
      this.make(spec);
    }

    /*
      Reset the graph to its initial specification.
    */


    Graph.prototype.reset = function() {
      if (!(this.initial_spec != null)) {
        throw poly.error.defn("No graph specification is passed in!");
      }
      this.dispose();
      return this.make(this.initial_spec);
    };

    /*
      Remove all existing items on the graph.
    */


    Graph.prototype.dispose = function() {
      var key, pane, renderer, _ref;
      renderer = poly.render(this.handleEvent, this.paper, this.scaleSet.scales, this.coord);
      _ref = this.panes;
      for (key in _ref) {
        pane = _ref[key];
        pane.dispose(renderer);
      }
      this.scaleSet.disposeLegends(renderer);
      this.scaleSet.disposeAxes(renderer);
      this.scaleSet.disposeTitles(renderer);
      this.scaleSet = null;
      this.axes = null;
      this.legends = null;
      this.dims = null;
      this.paper = null;
      this.coord = null;
      return this.facet = null;
    };

    /*
      Determine whether re-rendering of a particupar spec would require removing
      all existing items from the graph and starting all over again. This would
      happen if:
        * the coordinate has changed
        * the facet variable has changed
        * layers had changed
    */


    Graph.prototype.needDispose = function(spec) {
      if (this.coord && !_.isEqual(this.coord.spec, spec.coord)) {
        return true;
      } else if (this.facet && !_.isEqual(this.facet.spec, spec.facet)) {
        return true;
      } else {
        return false;
      }
    };

    /*
      Begin work to plot the graph. This function does only half of the work:
      i.e. things that needs to be done prior to data process. Because data
      process may be asynchronous, we pass in @merge() as a callback for when
      data processing is complete.
    */


    Graph.prototype.make = function(spec) {
      var dataChange, id, layerSpec, merge, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3,
        _this = this;
      if (spec == null) {
        spec = this.initial_spec;
      }
      spec = poly.spec.toStrictMode(spec);
      poly.spec.check(spec);
      this.spec = spec;
      if (this.needDispose(spec)) {
        this.dispose();
      }
      if ((_ref = this.coord) == null) {
        this.coord = poly.coord.make(this.spec.coord);
      }
      if ((_ref1 = this.facet) == null) {
        this.facet = poly.facet.make(this.spec.facet);
      }
      if (!this.dataSubscribed) {
        dataChange = this.handleEvent('data');
        _ref2 = spec.layers;
        for (id = _i = 0, _len = _ref2.length; _i < _len; id = ++_i) {
          layerSpec = _ref2[id];
          spec.layers[id].data.subscribe(dataChange);
        }
        this.dataSubscribed = true;
      }
      merge = _.after(spec.layers.length, this.merge);
      this.dataprocess = {};
      this.processedData = {};
      _ref3 = spec.layers;
      for (id = _j = 0, _len1 = _ref3.length; _j < _len1; id = ++_j) {
        layerSpec = _ref3[id];
        spec = this.spec.layers[id];
        this.dataprocess[id] = new poly.DataProcess(spec, this.facet.groups, spec.strict);
        this.dataprocess[id].make(spec, this.facet.groups, function(statData, metaData) {
          _this.processedData[id] = {
            statData: statData,
            metaData: metaData
          };
          return merge();
        });
      }
      return this.addHandler(polyjs.handler.tooltip());
    };

    /*
      Complete work to plot the graph. This includes three stages:
        1) Create each "pane". Each "pane" is a facet containing a smallversion
           of the chart, filtered to only data that falls within that facet.
        2) Merge the domains from each layer and each pane. This is used to
           define scales and determine the min/max point of each axis.
        3) Actually render the chart.
    */


    Graph.prototype.merge = function() {
      this.makePanes();
      this.mergeDomains();
      return this.render();
    };

    Graph.prototype.makePanes = function() {
      var datas, formatter, indices, key, pane, _ref, _ref1, _results;
      indices = this.facet.getIndices(this.processedData);
      datas = this.facet.groupData(this.processedData);
      formatter = this.facet.getFormatter();
      if ((_ref = this.panes) == null) {
        this.panes = this._makePanes(this.spec, indices, formatter);
      }
      _ref1 = this.panes;
      _results = [];
      for (key in _ref1) {
        pane = _ref1[key];
        _results.push(pane.make(this.spec, datas[key]));
      }
      return _results;
    };

    Graph.prototype.mergeDomains = function() {
      var domains, domainsets, _ref;
      domainsets = _.map(this.panes, function(p) {
        return p.domains;
      });
      domains = poly.domain.merge(domainsets);
      if ((_ref = this.scaleSet) == null) {
        this.scaleSet = this._makeScaleSet(this.spec, domains, this.facet);
      }
      this.scaleSet.make(this.spec.guides, domains, _.toArray(this.panes)[0].layers);
      if (!this.dims) {
        this.dims = this._makeDimensions(this.spec, this.scaleSet, this.facet);
        this.coord.make(this.dims);
        this.ranges = this.coord.ranges();
      }
      return this.scaleSet.setRanges(this.ranges);
    };

    Graph.prototype.render = function() {
      var clipping, key, offset, pane, renderer, scales, _ref, _ref1, _ref2;
      if ((this.spec.render != null) && this.spec.render === false) {
        return;
      }
      scales = this.scaleSet.scales;
      this.coord.setScales(scales);
      this.scaleSet.coord = this.coord;
      this.scaleSet.makeAxes();
      this.scaleSet.makeTitles((_ref = this.spec.title) != null ? _ref : '');
      this.scaleSet.makeLegends();
      this.dom = this.spec.dom;
      if ((_ref1 = this.paper) == null) {
        this.paper = this._makePaper(this.dom, this.dims.width, this.dims.height, this.handleEvent);
      }
      renderer = poly.render(this.handleEvent, this.paper, scales, this.coord);
      _ref2 = this.panes;
      for (key in _ref2) {
        pane = _ref2[key];
        offset = this.facet.getOffset(this.dims, key);
        clipping = this.coord.clipping(offset);
        pane.render(renderer, offset, clipping, this.dims);
      }
      this.scaleSet.renderAxes(this.dims, renderer, this.facet);
      this.scaleSet.renderTitles(this.dims, renderer);
      return this.scaleSet.renderLegends(this.dims, renderer);
      /* labels
      @scaleSet.renderFacetLabels @dims, rendererG, @facet
      @scaleSet.renderTitle @dims, rendererG, @facet
      */

    };

    Graph.prototype.addHandler = function(h) {
      return this.handlers.push(h);
    };

    Graph.prototype.removeHandler = function(h) {
      return this.handlers.splice(_.indexOf(this.handlers, h), 1);
    };

    Graph.prototype.handleEvent = function(type) {
      var graph, handler;
      graph = this;
      handler = function(event) {
        var end, f, h, obj, start, x, y, _i, _len, _ref, _ref1, _results;
        obj = this;
        if (type === 'select') {
          start = event.start, end = event.end;
          obj.evtData = graph.scaleSet.fromPixels(start, end);
        } else if (type === 'data') {
          obj.evtData = {};
        } else if (type === 'reset' || type === 'click' || type === 'mover' || type === 'mout') {
          obj.tooltip = obj.data('t');
          obj.evtData = obj.data('e');
          _ref = poly.getXY(poly.offset(graph.dom), event), x = _ref.x, y = _ref.y;
          f = graph.facet.getFacetInfo(graph.dims, x, y);
          if ((type === 'reset' || type === 'click') && !f) {
            return;
          }
        }
        _ref1 = graph.handlers;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          h = _ref1[_i];
          if (_.isFunction(h)) {
            _results.push(h(type, obj, event));
          } else {
            _results.push(h.handle(type, obj, event));
          }
        }
        return _results;
      };
      return _.throttle(handler, 1000);
    };

    Graph.prototype._makePanes = function(spec, indices, formatter) {
      var identifier, mindex, panes;
      panes = {};
      for (identifier in indices) {
        mindex = indices[identifier];
        panes[identifier] = poly.pane.make(spec, mindex, formatter);
      }
      return panes;
    };

    Graph.prototype._makeScaleSet = function(spec, domains, facet) {
      var tmpRanges;
      this.coord.make(poly.dim.guess(spec, facet.getGrid()));
      tmpRanges = this.coord.ranges();
      return poly.scaleset(tmpRanges, this.coord);
    };

    Graph.prototype._makeDimensions = function(spec, scaleSet, facet) {
      var _ref;
      scaleSet.makeAxes();
      scaleSet.makeTitles((_ref = this.spec.title) != null ? _ref : '');
      scaleSet.makeLegends();
      return poly.dim.make(spec, scaleSet, facet.getGrid());
    };

    Graph.prototype._makePaper = function(dom, width, height, handleEvent) {
      var paper;
      return paper = poly.paper(dom, width, height, handleEvent);
    };

    return Graph;

  })();

  poly.chart = function(spec) {
    return new Graph(spec);
  };

}).call(this);
  }
  return poly;
})(window.polyjs);

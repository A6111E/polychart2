// Generated by CoffeeScript 1.4.0
(function() {
  var Graph, poly,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  poly = this.poly || {};

  Graph = (function() {

    function Graph(spec) {
      this._legacy = __bind(this._legacy, this);

      this.handleEvent = __bind(this.handleEvent, this);

      this.merge = __bind(this.merge, this);

      this.reset = __bind(this.reset, this);

      var _ref;
      if (!(spec != null)) {
        throw poly.error.defn("No graph specification is passed in!");
      }
      this.handlers = [];
      this.layers = null;
      this.scaleSet = null;
      this.axes = null;
      this.legends = null;
      this.dims = null;
      this.paper = null;
      this.coord = (_ref = spec.coord) != null ? _ref : poly.coord.cartesian();
      this.initial_spec = spec;
      this.dataSubscribed = false;
      this.make(spec);
    }

    Graph.prototype.reset = function() {
      if (!(this.initial_spec != null)) {
        throw poly.error.defn("No graph specification is passed in!");
      }
      return this.make(this.initial_spec);
    };

    Graph.prototype.make = function(spec) {
      var dataChange, id, layerObj, merge, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
      if (spec == null) {
        spec = this.initial_spec;
      }
      this.spec = spec;
      if (!(spec.layers != null)) {
        throw poly.error.defn("No layers are defined in the specification.");
      }
      if ((_ref = this.layers) == null) {
        this.layers = this._makeLayers(this.spec);
      }
      if (!this.dataSubscribed) {
        dataChange = this.handleEvent('data');
        _ref1 = this.layers;
        for (id = _i = 0, _len = _ref1.length; _i < _len; id = ++_i) {
          layerObj = _ref1[id];
          if (!(spec.layers[id].data != null)) {
            throw poly.error.defn("Layer " + id + " does not have data to plot!");
          }
          spec.layers[id].data.subscribe(dataChange);
        }
        this.dataSubscribed = true;
      }
      merge = _.after(this.layers.length, this.merge);
      _ref2 = this.layers;
      _results = [];
      for (id = _j = 0, _len1 = _ref2.length; _j < _len1; id = ++_j) {
        layerObj = _ref2[id];
        _results.push(layerObj.make(spec.layers[id], merge));
      }
      return _results;
    };

    Graph.prototype.merge = function() {
      var clipping, dom, domains, layer, renderer, scales, _i, _len, _ref, _ref1, _ref2;
      domains = this._makeDomains(this.spec, this.layers);
      if ((_ref = this.scaleSet) == null) {
        this.scaleSet = this._makeScaleSet(this.spec, domains);
      }
      this.scaleSet.make(this.spec.guides, domains, this.layers);
      if (!this.dims) {
        this.dims = this._makeDimensions(this.spec, this.scaleSet);
        this.coord.make(this.dims);
        this.ranges = this.coord.ranges();
      }
      this.scaleSet.setRanges(this.ranges);
      this._legacy(domains);
      if (!this.spec.dom) {
        throw poly.error.defn("No DOM element specified. Where to make plot?");
      }
      dom = this.spec.dom;
      scales = this.scaleSet.scales;
      this.coord.setScales(scales);
      if ((_ref1 = this.paper) == null) {
        this.paper = this._makePaper(dom, this.dims.width, this.dims.height, this.handleEvent);
      }
      clipping = this.coord.clipping(this.dims);
      renderer = poly.render(this.handleEvent, this.paper, scales, this.coord, true, clipping);
      _ref2 = this.layers;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        layer = _ref2[_i];
        layer.render(renderer);
      }
      renderer = poly.render(this.handleEvent, this.paper, scales, this.coord, false);
      this.scaleSet.makeAxes();
      this.scaleSet.renderAxes(this.dims, renderer);
      this.scaleSet.makeLegends();
      return this.scaleSet.renderLegends(this.dims, renderer);
    };

    Graph.prototype.addHandler = function(h) {
      return this.handlers.push(h);
    };

    Graph.prototype.removeHandler = function(h) {
      return this.handlers.splice(_.indexOf(this.handlers, h), 1);
    };

    Graph.prototype.handleEvent = function(type) {
      var graph, handler;
      graph = this;
      handler = function(params) {
        var end, h, obj, start, _i, _len, _ref, _results;
        obj = this;
        if (type === 'select') {
          start = params.start, end = params.end;
          obj.evtData = graph.scaleSet.fromPixels(start, end);
        } else if (type === 'data') {
          obj.evtData = {};
        } else {
          obj.evtData = obj.data('e');
        }
        _ref = graph.handlers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          h = _ref[_i];
          if (_.isFunction(h)) {
            _results.push(h(type, obj));
          } else {
            _results.push(h.handle(type, obj));
          }
        }
        return _results;
      };
      return _.throttle(handler, 1000);
    };

    Graph.prototype._makeLayers = function(spec) {
      return _.map(spec.layers, function(layerSpec) {
        return poly.layer.make(layerSpec, spec.strict);
      });
    };

    Graph.prototype._makeDomains = function(spec, layers) {
      var _ref;
      if ((_ref = spec.guides) == null) {
        spec.guides = {};
      }
      return poly.domain.make(layers, spec.guides, spec.strict);
    };

    Graph.prototype._makeScaleSet = function(spec, domains) {
      var tmpRanges;
      this.coord.make(poly.dim.guess(spec));
      tmpRanges = this.coord.ranges();
      return poly.scaleset(tmpRanges, this.coord);
    };

    Graph.prototype._makeDimensions = function(spec, scaleSet) {
      return poly.dim.make(spec, scaleSet.makeAxes(), scaleSet.makeLegends());
    };

    Graph.prototype._makePaper = function(dom, width, height, handleEvent) {
      var paper;
      return paper = poly.paper(document.getElementById(dom), width, height, handleEvent);
    };

    Graph.prototype._legacy = function(domains) {
      var axes, k, v, _results;
      this.domains = domains;
      this.scales = this.scaleSet.scales;
      axes = this.scaleSet.makeAxes();
      this.ticks = {};
      _results = [];
      for (k in axes) {
        v = axes[k];
        _results.push(this.ticks[k] = v.ticks);
      }
      return _results;
    };

    return Graph;

  })();

  poly.chart = function(spec) {
    return new Graph(spec);
  };

  this.poly = poly;

}).call(this);
